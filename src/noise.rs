extern crate image;
extern crate rand;
use image::{GenericImage, DynamicImage, GenericImageView};
use image::Pixel;
use rand::Rng;

/// Add randomized noise to an image. 
/// This function adds a Gaussian Noise Sample to each pixel through incrementing each channel by a randomized offset.
/// This randomized offset is generated by creating a randomized thread pool.
/// 
/// # Arguments
/// * `name` - A DynamicImage that contains a view into the image.
/// 
/// # Example
///
/// ```
/// // For example, to increase the Red channel for all pixels by 10:
/// use photon::noise;
/// photon::noise::add_noise_rand(img);
/// ```

pub fn add_noise_rand(mut img: DynamicImage) -> DynamicImage {
    let (width, height) = img.dimensions();
    let mut rng = rand::thread_rng();

    for x in 0..width {
        for y in 0..height {
            let offset = rng.gen_range(0, 150);
            let px = img.get_pixel(x, y).map(|ch| if ch <= 255 - offset { ch + offset } else { 255});
            img.put_pixel(x, y, px);
        }
    }
    return img;
}

pub fn pink_noise(mut img: DynamicImage) -> DynamicImage {
    let (width, height) = img.dimensions();
    let mut rng = rand::thread_rng();

    for x in 0..width {
        for y in 0..height {
            let ran1: f64 = rng.gen(); // generates a float between 0 and 1
            let ran2: f64 = rng.gen();
            let ran3: f64 = rng.gen();

            let ranColor1: f64 = 0.6 + ran1 * 0.6;
            let ranColor2: f64 = 0.6 + ran2 * 0.1;
            let ranColor3: f64 = 0.6 + ran3 * 0.4;

        
            let offset = rng.gen_range(0, 150);
            let mut px = img.get_pixel(x, y);
            px.data[0] = (px.data[0] as f64 * 0.99 * ranColor1) as u8;
            px.data[1] = (px.data[1] as f64 * 0.99 * ranColor2) as u8;
            px.data[2] = (px.data[2] as f64 * 0.99 * ranColor3) as u8;
            img.put_pixel(x, y, px);
        }
    }
    return img;
}