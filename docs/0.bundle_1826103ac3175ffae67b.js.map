{"version":3,"sources":["webpack:///../crate/pkg/photon.js"],"names":["heap","Array","fill","undefined","push","heap_next","length","addHeapObject","obj","idx","passStringToWasm","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","cachegetUint8Memory","getUint8Memory","buffer","wasm","Uint8Array","passArray8ToWasm","arg","ptr","set","getArrayU8FromWasm","len","subarray","encodeInto","size","offset","mem","code","charCodeAt","slice","view","written","buf","encode","cachedGlobalArgumentPtr","globalArgumentPtr","cachegetUint32Memory","getUint32Memory","Uint32Array","getObject","dropObject","takeObject","ret","run","stack_pointer","addBorrowedObject","Error","get_image_data","canvas","ctx","putImageData","new_image","ptr2","open_image","PhotonImage","__wrap","canvas_wasm_only","to_raw_pixels","imgdata","retptr","rustptr","rustlen","realRet","base64_to_image","base64","ptr0","len0","base64_to_vec","photonimage_from_vec","vec","photonimage_from_imgdata","width","height","to_image_data","photon_image","draw_text_with_border","photon_img","text","x","y","ptr1","len1","draw_text","watermark","img","blend","photon_image2","blend_mode","len2","create_gradient","apply_gradient","image","noise_reduction","sharpen","edge_detection","identity","box_blur","gaussian_blur","detect_horizontal_lines","detect_vertical_lines","detect_45_deg_lines","detect_135_deg_lines","laplace","edge_one","emboss","sobel_horizontal","prewitt_horizontal","sobel_vertical","lch","mode","amt","hsl","hsv","hue_rotate_hsl","degrees","hue_rotate_hsv","hue_rotate_lch","saturate_hsl","level","saturate_lch","saturate_hsv","lighten_lch","lighten_hsl","lighten_hsv","darken_lch","darken_hsl","darken_hsv","desaturate_hsv","desaturate_hsl","desaturate_lch","crop","x1","y1","x2","y2","fliph","flipv","resize","channel_index","offset_red","offset_amt","offset_green","offset_blue","multiple_offsets","channel_index2","primary","colorize","solarize","inc_brightness","brightness","tint","r_offset","g_offset","b_offset","horizontal_strips","num_strips","vertical_strips","alter_channel","channel","alter_red_channel","alter_red_channel_dyn","alter_green_channel","alter_blue_channel","alter_two_channels","channel1","amt1","channel2","amt2","alter_channels","r_amt","g_amt","b_amt","remove_channel","min_filter","remove_red_channel","remove_green_channel","remove_blue_channel","swap_channels","selective_hue_rotate","ref_color","selective_lighten","selective_desaturate","selective_saturate","selective_greyscale","neue","lix","ryo","filter","filter_name","monochrome","sepia","grayscale","grayscale_human_corrected","desaturate","decompose_min","decompose_max","grayscale_shades","num_shades","r_grayscale","g_grayscale","b_grayscale","single_channel_grayscale","threshold","cachedTextDecoder","TextDecoder","getStringFromWasm","decode","__wbg_error_4bb6c2a97407129a","arg0","arg1","varg0","console","error","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","stack","retlen","__widl_instanceof_CanvasRenderingContext2D","CanvasRenderingContext2D","handleError","exnptr","e","__widl_f_get_image_data_CanvasRenderingContext2D","arg2","arg3","arg4","getImageData","__widl_f_put_image_data_CanvasRenderingContext2D","__widl_f_create_element_Document","varg1","createElement","isLikeNone","__widl_f_body_Document","val","body","__widl_instanceof_HTMLCanvasElement","HTMLCanvasElement","__widl_f_get_context_HTMLCanvasElement","getContext","__widl_f_width_HTMLCanvasElement","__widl_f_set_width_HTMLCanvasElement","__widl_f_height_HTMLCanvasElement","__widl_f_set_height_HTMLCanvasElement","cachegetUint8ClampedMemory","getClampedArrayU8FromWasm","Uint8ClampedArray","__widl_f_new_with_u8_clamped_array_and_sh_ImageData","ImageData","__widl_f_data_ImageData","data","__widl_f_append_child_Node","appendChild","__widl_f_set_text_content_Node","textContent","__widl_instanceof_Window","Window","__widl_f_document_Window","document","__wbg_newnoargs_a172f39151049128","Function","__wbg_call_8a9c8b0a32a202ff","call","__wbindgen_debug_string","i","len_ptr","toString","Object","prototype","debug","debug_str","type","description","name","isArray","className","builtInMatches","exec","JSON","stringify","_","message","__wbindgen_rethrow","__wbindgen_throw","this","freePhotonImage","create","img_data","Rgb","freeRgb","r","g","b","__wbindgen_object_clone_ref","__wbindgen_object_drop_ref"],"mappings":"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","file":"0.bundle_1826103ac3175ffae67b.js","sourcesContent":["import * as wasm from './photon_bg';\n\nconst heap = new Array(32);\n\nheap.fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nlet passStringToWasm;\nif (typeof cachedTextEncoder.encodeInto === 'function') {\n    passStringToWasm = function(arg) {\n\n\n        let size = arg.length;\n        let ptr = wasm.__wbindgen_malloc(size);\n        let offset = 0;\n        {\n            const mem = getUint8Memory();\n            for (; offset < arg.length; offset++) {\n                const code = arg.charCodeAt(offset);\n                if (code > 0x7F) break;\n                mem[ptr + offset] = code;\n            }\n        }\n\n        if (offset !== arg.length) {\n            arg = arg.slice(offset);\n            ptr = wasm.__wbindgen_realloc(ptr, size, size = offset + arg.length * 3);\n            const view = getUint8Memory().subarray(ptr + offset, ptr + size);\n            const ret = cachedTextEncoder.encodeInto(arg, view);\n\n            offset += ret.written;\n        }\n        WASM_VECTOR_LEN = offset;\n        return ptr;\n    };\n} else {\n    passStringToWasm = function(arg) {\n\n\n        let size = arg.length;\n        let ptr = wasm.__wbindgen_malloc(size);\n        let offset = 0;\n        {\n            const mem = getUint8Memory();\n            for (; offset < arg.length; offset++) {\n                const code = arg.charCodeAt(offset);\n                if (code > 0x7F) break;\n                mem[ptr + offset] = code;\n            }\n        }\n\n        if (offset !== arg.length) {\n            const buf = cachedTextEncoder.encode(arg.slice(offset));\n            ptr = wasm.__wbindgen_realloc(ptr, size, size = offset + buf.length);\n            getUint8Memory().set(buf, ptr + offset);\n            offset += buf.length;\n        }\n        WASM_VECTOR_LEN = offset;\n        return ptr;\n    };\n}\n\nfunction passArray8ToWasm(arg) {\n    const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n    getUint8Memory().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm(ptr, len) {\n    return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedGlobalArgumentPtr = null;\nfunction globalArgumentPtr() {\n    if (cachedGlobalArgumentPtr === null) {\n        cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();\n    }\n    return cachedGlobalArgumentPtr;\n}\n\nlet cachegetUint32Memory = null;\nfunction getUint32Memory() {\n    if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* [temp] Check if WASM is supported.\n* @returns {void}\n*/\nexport function run() {\n    return wasm.run();\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Get the ImageData from a 2D canvas context\n* @param {any} canvas\n* @param {any} ctx\n* @returns {any}\n*/\nexport function get_image_data(canvas, ctx) {\n    try {\n        return takeObject(wasm.get_image_data(addBorrowedObject(canvas), addBorrowedObject(ctx)));\n\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n\n    }\n\n}\n\n/**\n* Place a PhotonImage onto a 2D canvas.\n* @param {any} canvas\n* @param {any} ctx\n* @param {PhotonImage} new_image\n* @returns {void}\n*/\nexport function putImageData(canvas, ctx, new_image) {\n    const ptr2 = new_image.ptr;\n    new_image.ptr = 0;\n    return wasm.putImageData(addHeapObject(canvas), addHeapObject(ctx), ptr2);\n}\n\n/**\n* Convert a HTML5 Canvas Element to a PhotonImage.\n*\n* This converts the ImageData found in the canvas context to a PhotonImage,\n* which can then have effects or filters applied to it.\n* @param {any} canvas\n* @param {any} ctx\n* @returns {PhotonImage}\n*/\nexport function open_image(canvas, ctx) {\n    return PhotonImage.__wrap(wasm.open_image(addHeapObject(canvas), addHeapObject(ctx)));\n}\n\n/**\n* Experimental WASM-only canvas manipulation; without converting to PhotonImages etc.,\n* @param {any} canvas\n* @param {any} ctx\n* @returns {void}\n*/\nexport function canvas_wasm_only(canvas, ctx) {\n    return wasm.canvas_wasm_only(addHeapObject(canvas), addHeapObject(ctx));\n}\n\n/**\n* Convert ImageData to a raw pixel vec of u8s.\n* @param {any} imgdata\n* @returns {Uint8Array}\n*/\nexport function to_raw_pixels(imgdata) {\n    const retptr = globalArgumentPtr();\n    wasm.to_raw_pixels(retptr, addHeapObject(imgdata));\n    const mem = getUint32Memory();\n    const rustptr = mem[retptr / 4];\n    const rustlen = mem[retptr / 4 + 1];\n\n    const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n    wasm.__wbindgen_free(rustptr, rustlen * 1);\n    return realRet;\n\n}\n\n/**\n* Convert a base64 string to a PhotonImage.\n* @param {string} base64\n* @returns {PhotonImage}\n*/\nexport function base64_to_image(base64) {\n    const ptr0 = passStringToWasm(base64);\n    const len0 = WASM_VECTOR_LEN;\n    try {\n        return PhotonImage.__wrap(wasm.base64_to_image(ptr0, len0));\n\n    } finally {\n        wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    }\n\n}\n\n/**\n* Convert a base64 string to a Vec of u8s.\n* @param {string} base64\n* @returns {Uint8Array}\n*/\nexport function base64_to_vec(base64) {\n    const ptr0 = passStringToWasm(base64);\n    const len0 = WASM_VECTOR_LEN;\n    const retptr = globalArgumentPtr();\n    try {\n        wasm.base64_to_vec(retptr, ptr0, len0);\n        const mem = getUint32Memory();\n        const rustptr = mem[retptr / 4];\n        const rustlen = mem[retptr / 4 + 1];\n\n        const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n        wasm.__wbindgen_free(rustptr, rustlen * 1);\n        return realRet;\n\n\n    } finally {\n        wasm.__wbindgen_free(ptr0, len0 * 1);\n\n    }\n\n}\n\n/**\n* Create a PhotonImage from a raw vec of u8s, representing raw image pixels.\n* @param {Uint8Array} vec\n* @returns {PhotonImage}\n*/\nexport function photonimage_from_vec(vec) {\n    const ptr0 = passArray8ToWasm(vec);\n    const len0 = WASM_VECTOR_LEN;\n    return PhotonImage.__wrap(wasm.photonimage_from_vec(ptr0, len0));\n}\n\n/**\n* Create a PhotonImage from ImageData.\n* @param {any} imgdata\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nexport function photonimage_from_imgdata(imgdata, width, height) {\n    return PhotonImage.__wrap(wasm.photonimage_from_imgdata(addHeapObject(imgdata), width, height));\n}\n\n/**\n* Convert a PhotonImage to JS-compatible ImageData.\n* @param {PhotonImage} photon_image\n* @returns {any}\n*/\nexport function to_image_data(photon_image) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    return takeObject(wasm.to_image_data(ptr0));\n}\n\n/**\n* Add bordered-text to an image.\n* The only font available as of now is Roboto.\n* Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `text` - Text string to be drawn to the image.\n* * `x` - x-coordinate of where first letter\\'s 1st pixel should be drawn.\n* * `y` - y-coordinate of where first letter\\'s 1st pixel should be drawn.\n*\n* # Example\n* ```\n* // For example to draw the string \\\"Welcome to Photon!\\\" at 10, 10:\n* use photon::text::draw_text_with_border;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/cats.PNG\\\");\n*\n* draw_text_with_border(&mut img, \\\"Welcome to Photon!\\\", 10, 10);\n* ```\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @returns {void}\n*/\nexport function draw_text_with_border(photon_img, text, x, y) {\n    const ptr1 = passStringToWasm(text);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.draw_text_with_border(photon_img.ptr, ptr1, len1, x, y);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Add text to an image.\n* The only font available as of now is Roboto.\n* Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `text` - Text string to be drawn to the image.\n* * `x` - x-coordinate of where first letter\\'s 1st pixel should be drawn.\n* * `y` - y-coordinate of where first letter\\'s 1st pixel should be drawn.\n*\n* # Example\n* ```\n* // For example to draw the string \\\"Welcome to Photon!\\\" at 10, 10:\n* use photon::text::draw_text;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/cats.PNG\\\");\n*\n* draw_text(&mut img, \\\"Welcome to Photon!\\\", 10, 10);\n* ```\n* @param {PhotonImage} photon_img\n* @param {string} text\n* @param {number} x\n* @param {number} y\n* @returns {void}\n*/\nexport function draw_text(photon_img, text, x, y) {\n    const ptr1 = passStringToWasm(text);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.draw_text(photon_img.ptr, ptr1, len1, x, y);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Add a watermark to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `watermark` - The watermark to be placed onto the `img` image.\n* * `x` - The x coordinate where the watermark\\'s top corner should be positioned.\n* * `y` - The y coordinate where the watermark\\'s top corner should be positioned.\n* # Example\n*\n* ```\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon::multiple;\n* photon::multiple::watermark(img, watermark, 30, 40);\n* ```\n* @param {PhotonImage} img\n* @param {PhotonImage} watermark\n* @param {number} x\n* @param {number} y\n* @returns {void}\n*/\nexport function watermark(img, watermark, x, y) {\n    const ptr1 = watermark.ptr;\n    watermark.ptr = 0;\n    return wasm.watermark(img.ptr, ptr1, x, y);\n}\n\n/**\n* Blend two images together.\n* The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n* The blend modes available include: `overlay`, `over`, `atop`, `xor`, `multiply`, `burn`, `soft_light`, `hard_light`\n* `difference`, `lighten`, `darken`, `dodge`, `plus`, `exclusion` (more to come)\n* NOTE: The first image must be smaller than the second image passed as params.\n* If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n* in the second image.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `img2` - The 2nd DynamicImage to be blended with the first.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon::multiple;\n* photon::multiple::watermark(img, watermark, 30, 40);\n* ```\n* @param {PhotonImage} photon_image\n* @param {PhotonImage} photon_image2\n* @param {string} blend_mode\n* @returns {void}\n*/\nexport function blend(photon_image, photon_image2, blend_mode) {\n    const ptr2 = passStringToWasm(blend_mode);\n    const len2 = WASM_VECTOR_LEN;\n    try {\n        return wasm.blend(photon_image.ptr, photon_image2.ptr, ptr2, len2);\n\n    } finally {\n        wasm.__wbindgen_free(ptr2, len2 * 1);\n\n    }\n\n}\n\n/**\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nexport function create_gradient(width, height) {\n    return PhotonImage.__wrap(wasm.create_gradient(width, height));\n}\n\n/**\n* Apply a gradient to an image.\n* @param {PhotonImage} image\n* @returns {void}\n*/\nexport function apply_gradient(image) {\n    return wasm.apply_gradient(image.ptr);\n}\n\n/**\n* Noise reduction.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to sharpen an image:\n* use photon::conv::sharpen;\n* photon::channels::sharpen(img);\n* ```\n* Adds a constant to a select R, G, or B channel\\'s value.\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function noise_reduction(photon_image) {\n    return wasm.noise_reduction(photon_image.ptr);\n}\n\n/**\n* Sharpen an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to sharpen an image:\n* use photon::conv::sharpen;\n* photon::channels::sharpen(img);\n* ```\n* Adds a constant to a select R, G, or B channel\\'s value.\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function sharpen(photon_image) {\n    return wasm.sharpen(photon_image.ptr);\n}\n\n/**\n* Apply edge detection to an image, to create a dark version with its edges highlighted.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* photon::conv::edge_detection(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function edge_detection(photon_image) {\n    return wasm.edge_detection(photon_image.ptr);\n}\n\n/**\n* Apply an identity kernel convolution to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply an identity kernel convolution:\n* use photon::channels;\n* photon::conv::identity(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function identity(photon_image) {\n    return wasm.identity(photon_image.ptr);\n}\n\n/**\n* Apply a box blur effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a box blur effect:\n* use photon::channels;\n* photon::conv::box_blur(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function box_blur(photon_image) {\n    return wasm.box_blur(photon_image.ptr);\n}\n\n/**\n* Apply a gaussian blur effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a gaussian blur effect to an image:\n* use photon::channels;\n* photon::conv::gaussian_blur(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function gaussian_blur(photon_image) {\n    return wasm.gaussian_blur(photon_image.ptr);\n}\n\n/**\n* Detect horizontal lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the horizontal lines in an image:\n* use photon::channels;\n* photon::conv::detect_horizontal_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function detect_horizontal_lines(photon_image) {\n    return wasm.detect_horizontal_lines(photon_image.ptr);\n}\n\n/**\n* Detect vertical lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the vertical lines in an image:\n* use photon::channels;\n* photon::conv::detect_vertical_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function detect_vertical_lines(photon_image) {\n    return wasm.detect_vertical_lines(photon_image.ptr);\n}\n\n/**\n* Detect lines at a forty five degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the lines at a forty five degree angle in an image:\n* use photon::channels;\n* photon::conv::detect_fortyfivedeg_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function detect_45_deg_lines(photon_image) {\n    return wasm.detect_45_deg_lines(photon_image.ptr);\n}\n\n/**\n* Detect lines at a 135 degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to display the lines at a 135 degree angle in an image:\n* use photon::channels;\n* photon::conv::detect_hundredthirtyfive_deg_lines(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function detect_135_deg_lines(photon_image) {\n    return wasm.detect_135_deg_lines(photon_image.ptr);\n}\n\n/**\n* Apply a standard laplace convolution.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a laplace effect:\n* use photon::conv;\n* photon::conv::laplace(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function laplace(photon_image) {\n    return wasm.laplace(photon_image.ptr);\n}\n\n/**\n* Preset edge effect.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply this effect:\n* use photon::conv;\n* photon::conv::edge_one(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function edge_one(photon_image) {\n    return wasm.edge_one(photon_image.ptr);\n}\n\n/**\n* Apply an emboss effect to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply an emboss effect:\n* use photon::conv;\n* photon::conv::emboss(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function emboss(photon_image) {\n    return wasm.emboss(photon_image.ptr);\n}\n\n/**\n* Apply a horizontal Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a horizontal Sobel filter:\n* use photon::conv;\n* photon::conv::sobel_horizontal(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function sobel_horizontal(photon_image) {\n    return wasm.sobel_horizontal(photon_image.ptr);\n}\n\n/**\n* Apply a horizontal Prewitt convolution to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a horizontal Prewitt convolution effect:\n* use photon::conv;\n* photon::conv::prewitt_horizontal(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function prewitt_horizontal(photon_image) {\n    return wasm.prewitt_horizontal(photon_image.ptr);\n}\n\n/**\n* Apply a vertical Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n*\n* # Example\n*\n* ```\n* // For example, to apply a vertical Sobel filter:\n* use photon::conv;\n* photon::conv::sobel_vertical(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function sobel_vertical(photon_image) {\n    return wasm.sobel_vertical(photon_image.ptr);\n}\n\n/**\n* Apply gamma correction.\n* Image manipulation effects in the LCh colour space\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```\n* // For example to increase the saturation by 10%:\n* use photon::color_spaces::lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* lch(&mut img, \\\"saturate\\\", 0.1);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {void}\n*/\nexport function lch(photon_image, mode, amt) {\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.lch(photon_image.ptr, ptr1, len1, amt);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Image manipulation effects in the HSL colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```\n* // For example to increase the saturation by 10%:\n* use photon::color_spaces::hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* hsl(&mut img, \\\"saturate\\\", 0.1);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {void}\n*/\nexport function hsl(photon_image, mode, amt) {\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.hsl(photon_image.ptr, ptr1, len1, amt);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Image manipulation in the HSV colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n*\n* # Example\n* ```\n* // For example to increase the saturation by 10%:\n* use photon::color_spaces::hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* hsv(&mut img, \\\"saturate\\\", 0.1);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n* @returns {void}\n*/\nexport function hsv(photon_image, mode, amt) {\n    const ptr1 = passStringToWasm(mode);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.hsv(photon_image.ptr, ptr1, len1, amt);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - The number of degrees to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon::color_spaces::hue_rotate_hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* hue_rotate_hsl(&mut img, 120);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {void}\n*/\nexport function hue_rotate_hsl(img, degrees) {\n    return wasm.hue_rotate_hsl(img.ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - The number of degrees to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```\n* // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:\n* use photon::color_spaces::hue_rotate_hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* hue_rotate_hsv(&mut img, 120);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {void}\n*/\nexport function hue_rotate_hsv(img, degrees) {\n    return wasm.hue_rotate_hsv(img.ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - The number of degrees to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon::color_spaces::hue_rotate_lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* hue_rotate_lch(&mut img, 120);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n* @returns {void}\n*/\nexport function hue_rotate_lch(img, degrees) {\n    return wasm.hue_rotate_lch(img.ptr, degrees);\n}\n\n/**\n* Increase the image\\'s saturation by converting each pixel\\'s colour to the HSL colour space\n* and increasing the colour\\'s saturation.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to increase saturation by 10% in the HSL colour space:\n* use photon::color_spaces::saturate_hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* saturate_hsl(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function saturate_hsl(img, level) {\n    return wasm.saturate_hsl(img.ptr, level);\n}\n\n/**\n* Increase the image\\'s saturation in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to increase saturation by 40% in the Lch colour space:\n* use photon::color_spaces::saturate_lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* saturate_lch(&mut img, 0.4);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function saturate_lch(img, level) {\n    return wasm.saturate_lch(img.ptr, level);\n}\n\n/**\n* Increase the image\\'s saturation in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to increase saturation by 30% in the HSV colour space:\n* use photon::color_spaces::saturate_hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* saturate_hsv(&mut img, 0.3);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function saturate_hsv(img, level) {\n    return wasm.saturate_hsv(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to lighten an image by 10% in the LCh colour space:\n* use photon::color_spaces::lighten_lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* lighten_lch(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function lighten_lch(img, level) {\n    return wasm.lighten_lch(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to lighten an image by 10% in the HSL colour space:\n* use photon::color_spaces::lighten_hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* lighten_hsl(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function lighten_hsl(img, level) {\n    return wasm.lighten_hsl(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to lighten an image by 10% in the HSV colour space:\n* use photon::color_spaces::lighten_hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* lighten_hsv(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function lighten_hsv(img, level) {\n    return wasm.lighten_hsv(img.ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to darken an image by 10% in the LCh colour space:\n* use photon::color_spaces::darken_lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* darken_lch(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function darken_lch(img, level) {\n    return wasm.darken_lch(img.ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to darken an image by 10% in the HSL colour space:\n* use photon::color_spaces::darken_hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* darken_hsl(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function darken_hsl(img, level) {\n    return wasm.darken_hsl(img.ptr, level);\n}\n\n/**\n* Darken the image\\'s colours by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to darken an image by 10% in the HSV colour space:\n* use photon::color_spaces::darken_hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* darken_hsv(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function darken_hsv(img, level) {\n    return wasm.darken_hsv(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to desaturate an image by 10% in the HSV colour space:\n* use photon::color_spaces::desaturate_hsv;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/mountains.PNG\\\");\n*\n* desaturate_hsv(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function desaturate_hsv(img, level) {\n    return wasm.desaturate_hsv(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon::color_spaces::desaturate_hsl;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* desaturate_hsl(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function desaturate_hsl(img, level) {\n    return wasm.desaturate_hsl(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon::color_spaces::desaturate_lch;\n*\n* // Open the image. A PhotonImage is returned.\n* let img: PhotonImage = open_image(\\\"images/flowers.PNG\\\");\n*\n* desaturate_lch(&mut img, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n* @returns {void}\n*/\nexport function desaturate_lch(img, level) {\n    return wasm.desaturate_lch(img.ptr, level);\n}\n\n/**\n* Crop an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* ## Example\n*\n* ```\n* // For example, to crop an image at (0, 0) to (500, 800)\n* use photon::transform;\n* let img = photon::open_image(\\\"img.jpg\\\");\n* let cropped_img = photon::transform::crop(&mut img, 0, 0, 500, 800);\n* // Write the contents of this image in JPG format.\n* photon::helpers::save_image(cropped_img, \\\"cropped_image.png\\\");\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} x1\n* @param {number} y1\n* @param {number} x2\n* @param {number} y2\n* @returns {PhotonImage}\n*/\nexport function crop(photon_image, x1, y1, x2, y2) {\n    return PhotonImage.__wrap(wasm.crop(photon_image.ptr, x1, y1, x2, y2));\n}\n\n/**\n* Flip an image horizontally.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* ## Example\n*\n* ```\n* // For example, to flip an image horizontally:\n* use photon::transform;\n* let img = photon::open_image(\\\"img.jpg\\\");\n* let new_img = photon::transform::fliph(&mut img);\n* // Write the contents of this image in JPG format.\n* photon::helpers::save_image(new_img, \\\"new_image.png\\\");\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function fliph(photon_image) {\n    return wasm.fliph(photon_image.ptr);\n}\n\n/**\n* Flip an image vertically.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* ## Example\n*\n* ```\n* // For example, to flip an image vertically:\n* use photon::transform;\n* let img = photon::open_image(\\\"img.jpg\\\");\n* let new_img = photon::transform::flipv(&mut img);\n* // Write the contents of this image in JPG format.\n* photon::helpers::save_image(new_img, \\\"new_image.png\\\");\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function flipv(photon_image) {\n    return wasm.flipv(photon_image.ptr);\n}\n\n/**\n* Resize an image on the web.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n* @param {PhotonImage} photon_img\n* @param {number} width\n* @param {number} height\n* @returns {any}\n*/\nexport function resize(photon_img, width, height) {\n    return takeObject(wasm.resize(photon_img.ptr, width, height));\n}\n\n/**\n* Adds an offset to the image by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```\n* // For example, to offset pixels by 30 pixels on the red channel:\n* use photon::effects;\n* photon::effects::offset(img, 0, 30);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel_index\n* @param {number} offset\n* @returns {void}\n*/\nexport function offset(photon_image, channel_index, offset) {\n    return wasm.offset(photon_image.ptr, channel_index, offset);\n}\n\n/**\n* Adds an offset to the red channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the red channel by.\n* # Example\n*\n* ```\n* // For example, to add an offset to the red channel by 30 pixels.\n* use photon::effects;\n* photon::effects::offset_red(img, 30);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {void}\n*/\nexport function offset_red(img, offset_amt) {\n    return wasm.offset_red(img.ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the green channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the green channel by.\n* # Example\n*\n* ```\n* // For example, to add an offset to the green channel by 30 pixels.\n* use photon::effects;\n* photon::effects::offset_green(img, 40);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {void}\n*/\nexport function offset_green(img, offset_amt) {\n    return wasm.offset_green(img.ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the blue channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset_amt` - The offset you want to move the blue channel by.\n* # Example\n* // For example, to add an offset to the green channel by 40 pixels.\n* use photon::effects;\n* photon::effects::offset_blue(img, 40);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n* @returns {void}\n*/\nexport function offset_blue(img, offset_amt) {\n    return wasm.offset_blue(img.ptr, offset_amt);\n}\n\n/**\n* Adds multiple offsets to the image by a certain number of pixels (on two channels).\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```\n* // For example, to add a 30-pixel offset to both the red and blue channels:\n* use photon::effects;\n* photon::effects::multiple_offsets(img, 30, 0, 2);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} offset\n* @param {number} channel_index\n* @param {number} channel_index2\n* @returns {void}\n*/\nexport function multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    return wasm.multiple_offsets(photon_image.ptr, offset, channel_index, channel_index2);\n}\n\n/**\n* Reduces an image to the primary colours.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to add a primary colour effect to an image of type `DynamicImage`:\n* use photon::effects;\n* photon::effects::primary(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function primary(photon_image) {\n    return wasm.primary(photon_image.ptr);\n}\n\n/**\n* Colorizes the green channels of the image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon::effects;\n* photon::effects::colorize(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function colorize(photon_image) {\n    return wasm.colorize(photon_image.ptr);\n}\n\n/**\n* Applies a solarizing effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon::effects;\n* photon::effects::solarize(img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function solarize(photon_image) {\n    return wasm.solarize(photon_image.ptr);\n}\n\n/**\n* Increase the brightness of an image by a factor.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `brightness` - A u8 to add to the brightness.\n* # Example\n*\n* ```\n* photon::effects::inc_brightness(img, 10);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} brightness\n* @returns {void}\n*/\nexport function inc_brightness(photon_image, brightness) {\n    return wasm.inc_brightness(photon_image.ptr, brightness);\n}\n\n/**\n* Tint an image by adding an offset to averaged RGB channel values.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `r_offset` - The amount the  R channel should be incremented by.\n* * `g_offset` - The amount the G channel should be incremented by.\n* * `b_offset` - The amount the B channel should be incremented by.\n* # Example\n*\n* ```\n* // For example, to tint an image of type `PhotonImage`:\n* photon::tint(img, 10, 20, 15);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n* @returns {void}\n*/\nexport function tint(photon_image, r_offset, g_offset, b_offset) {\n    return wasm.tint(photon_image.ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n* @returns {void}\n*/\nexport function horizontal_strips(photon_image, num_strips) {\n    return wasm.horizontal_strips(photon_image.ptr, num_strips);\n}\n\n/**\n* Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n* @returns {void}\n*/\nexport function vertical_strips(photon_image, num_strips) {\n    return wasm.vertical_strips(photon_image.ptr, num_strips);\n}\n\n/**\n* Alter a select channel by incrementing or decrementing its value by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,\n* representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)\n* * `amount` - The amount to increment/decrement the channel\\'s value by for that pixel.\n* A positive value will increment/decrement the channel\\'s value, a negative value will decrement the channel\\'s value.\n*\n* ## Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* let img = photon::open_image(\\\"img.jpg\\\");\n* photon::channels::alter_channel(&mut img, 0, 10);\n* // Write the contents of this image in JPG format.\n* photon::helpers::save_image(img, \\\"new_image.png\\\");\n* ```\n*\n* Adds a constant to a select R, G, or B channel\\'s value.\n*\n* ### Decrease a channel\\'s value\n* // For example, to decrease the Green channel for all pixels by 20:\n* ```\n* use photon::channels;\n* photon::channels::alter_channel(&mut img, 1, -20);\n* ```\n* **Note**: Note the use of a minus symbol when decreasing the channel.\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} amt\n* @returns {void}\n*/\nexport function alter_channel(img, channel, amt) {\n    return wasm.alter_channel(img.ptr, channel, amt);\n}\n\n/**\n* Increment or decrement every pixel\\'s Red channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `amt` - The amount to increment or decrement the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon::channels;\n* photon::channels::alter_red_channel(&mut img, 10);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} amt\n* @returns {void}\n*/\nexport function alter_red_channel(photon_image, amt) {\n    return wasm.alter_red_channel(photon_image.ptr, amt);\n}\n\n/**\n* @param {PhotonImage} photon_image\n* @param {number} amt\n* @returns {void}\n*/\nexport function alter_red_channel_dyn(photon_image, amt) {\n    return wasm.alter_red_channel_dyn(photon_image.ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel\\'s Green channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment/decrement the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Green channel for all pixels by 20:\n* use photon::channels;\n* photon::channels::alter_green_channel(&mut img, 10);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n* @returns {void}\n*/\nexport function alter_green_channel(img, amt) {\n    return wasm.alter_green_channel(img.ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel\\'s Blue channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment or decrement the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the Blue channel for all pixels by 10:\n* use photon::channels;\n* photon::channels::alter_blue_channel(&mut img, 10);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n* @returns {void}\n*/\nexport function alter_blue_channel(img, amt) {\n    return wasm.alter_blue_channel(img.ptr, amt);\n}\n\n/**\n* Increment/decrement two channels\\' values simultaneously by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt1` - The amount to increment/decrement the channel\\'s value by for that pixel.\n* * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt2` - The amount to increment/decrement the channel\\'s value by for that pixel.\n*\n* # Example\n*\n* ```\n* // For example, to increase the values of the Red and Blue channels per pixel:\n* photon::channels::inc_two_channels(&mut img, 0, 10, 2, 20);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} amt1\n* @param {number} channel2\n* @param {number} amt2\n* @returns {void}\n*/\nexport function alter_two_channels(img, channel1, amt1, channel2, amt2) {\n    return wasm.alter_two_channels(img.ptr, channel1, amt1, channel2, amt2);\n}\n\n/**\n* Increment all 3 channels\\' values by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `r_amt` - The amount to increment/decrement the Red channel by.\n* * `g_amt` - The amount to increment/decrement the Green channel by.\n* * `b_amt` - The amount to increment/decrement the Blue channel by.\n*\n* # Example\n*\n* ```\n* // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n* // and the Blue channel by 50:\n* // photon::channels::alter_channels(&mut img, 10, 20, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} r_amt\n* @param {number} g_amt\n* @param {number} b_amt\n* @returns {void}\n*/\nexport function alter_channels(img, r_amt, g_amt, b_amt) {\n    return wasm.alter_channels(img.ptr, r_amt, g_amt, b_amt);\n}\n\n/**\n* Set a certain channel to zero, thus removing the channel\\'s influence in the pixels\\' final rendered colour.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n* * `min_filter` - Value between 0 and 255. Only remove the channel if the current pixel\\'s channel value is less than this minimum filter. To completely\n* remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n* then channel would be 0 and min_filter would be 50.\n*\n* # Example\n*\n* ```\n* // For example, to remove the Red channel with a min_filter of 100:\n* photon::channels::remove_channel(&mut img, 0, 100);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} min_filter\n* @returns {void}\n*/\nexport function remove_channel(img, channel, min_filter) {\n    return wasm.remove_channel(img.ptr, channel, min_filter);\n}\n\n/**\n* Remove the Red channel\\'s influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the red channel for red channel pixel values less than 50:\n* photon::channels::remove_red_channel(&mut img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {void}\n*/\nexport function remove_red_channel(img, min_filter) {\n    return wasm.remove_red_channel(img.ptr, min_filter);\n}\n\n/**\n* Remove the Green channel\\'s influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the green channel for green channel pixel values less than 50:\n* photon::channels::remove_green_channel(img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {void}\n*/\nexport function remove_green_channel(img, min_filter) {\n    return wasm.remove_green_channel(img.ptr, min_filter);\n}\n\n/**\n* Remove the Blue channel\\'s influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel\\'s channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```\n* // For example, to remove the blue channel for blue channel pixel values less than 50:\n* photon::channels::remove_blue_channel(&mut img, 50);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n* @returns {void}\n*/\nexport function remove_blue_channel(img, min_filter) {\n    return wasm.remove_blue_channel(img.ptr, min_filter);\n}\n\n/**\n* Swap two channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n* * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n*\n* # Example\n*\n* ```\n* // For example, to swap the values of the Red channel with the values of the Blue channel:\n* photon::channels::swap_channels(&mut img, 0, 2);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} channel2\n* @returns {void}\n*/\nexport function swap_channels(img, channel1, channel2) {\n    return wasm.swap_channels(img.ptr, channel1, channel2);\n}\n\n/**\n* Selective hue rotation.\n*\n* Only rotate the hue of a pixel if its RGB values are within a specified range.\n* This function only rotates a pixel\\'s hue to another  if it is visually similar to the colour specified.\n* For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `degrees` - The amount of degrees to hue rotate by.\n*\n* # Example\n*\n* ```\n* // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_hue_rotate(&mut img, ref_color, 180);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @param {number} degrees\n* @returns {void}\n*/\nexport function selective_hue_rotate(photon_image, ref_color, degrees) {\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return wasm.selective_hue_rotate(photon_image.ptr, ptr1, degrees);\n}\n\n/**\n* Selectively lighten an image.\n*\n* Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n* For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n*\n* # Example\n*\n* ```\n* // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_lighten(&mut img, ref_color, 0.2);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {void}\n*/\nexport function selective_lighten(img, ref_color, amt) {\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return wasm.selective_lighten(img.ptr, ptr1, amt);\n}\n\n/**\n* Selectively desaturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of desaturate the colour by.\n*\n* # Example\n*\n* ```\n* // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_desaturate(&mut img, ref_color, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {void}\n*/\nexport function selective_desaturate(img, ref_color, amt) {\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return wasm.selective_desaturate(img.ptr, ptr1, amt);\n}\n\n/**\n* Selectively saturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of saturate the colour by.\n*\n* # Example\n*\n* ```\n* // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_saturate(&mut img, ref_color, 0.1);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n* @returns {void}\n*/\nexport function selective_saturate(img, ref_color, amt) {\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return wasm.selective_saturate(img.ptr, ptr1, amt);\n}\n\n/**\n* Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n* Only changes the colour of a pixel if its RGB values are within a specified range.\n*\n* (Similarity between two colours is calculated via the CIE76 formula.)\n* For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be\n* kept in the photo.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n*\n* # Example\n*\n* ```\n* // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n* let ref_color = Rgb{20, 40, 60};\n* photon::channels::selective_greyscale(&mut img, ref_color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @returns {void}\n*/\nexport function selective_greyscale(photon_image, ref_color) {\n    const ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    const ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    return wasm.selective_greyscale(ptr0, ptr1);\n}\n\n/**\n* Solarization on the Blue channel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```\n* photon::filters::neue(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function neue(photon_image) {\n    return wasm.neue(photon_image.ptr);\n}\n\n/**\n* Solarization on the Red and Green channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```\n* photon::filters::lix(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function lix(photon_image) {\n    return wasm.lix(photon_image.ptr);\n}\n\n/**\n* Solarization on the Red and Blue channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```\n* photon::filters::ryo(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function ryo(photon_image) {\n    return wasm.ryo(photon_image.ptr);\n}\n\n/**\n* Apply a filter to an image. Over 20 filters are available.\n* The filters are as follows:\n* * **oceanic**: Add an aquamarine-tinted hue to an image.\n* * **islands**: Aquamarine tint.\n* * **marine**: Add a green/blue mixed hue to an image.\n* * **seagreen**: Dark green hue, with tones of blue.\n* * **flagblue**: Royal blue tint\n* * **liquid**: Blue-inspired tint.\n* * **diamante**: Custom filter with a blue/turquoise tint.\n* * **radio**: Fallout-style radio effect.\n* * **twenties**: Slight-blue tinted historical effect.\n* * **rosetint**: Rose-tinted filter.\n* * **mauve**: Purple-infused filter.\n* * **bluechrome**: Blue monochrome effect.\n* * **vintage**: Vintage filter with a red tint.\n* * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n* * **serenity**: Custom filter with an increase in the Blue channel\\'s values.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```\n* // For example, to add a filter called \\\"vintage\\\" to an image:\n* use photon::filters;\n* photon::filters::filter(&mut img, \\\"vintage\\\");\n* ```\n* @param {PhotonImage} img\n* @param {string} filter_name\n* @returns {void}\n*/\nexport function filter(img, filter_name) {\n    const ptr1 = passStringToWasm(filter_name);\n    const len1 = WASM_VECTOR_LEN;\n    try {\n        return wasm.filter(img.ptr, ptr1, len1);\n\n    } finally {\n        wasm.__wbindgen_free(ptr1, len1 * 1);\n\n    }\n\n}\n\n/**\n* Apply a monochrome effect of a certain colour.\n*\n* It does so by averaging the R, G, and B values of a pixel, and then adding a\n* separate value to that averaged value for each channel to produce a tint.\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `r_offset` - The value to add to the Red channel per pixel.\n* * `g_offset` - The value to add to the Green channel per pixel.\n* * `b_offset` - The value to add to the Blue channel per pixel.\n*\n* # Example\n*\n* ```\n* // For example, to apply a monochrome effect to an image:\n* use photon::monochrome;\n* monochrome::monochroma(&mut img, 40, 50, 100);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n* @returns {void}\n*/\nexport function monochrome(photon_image, r_offset, g_offset, b_offset) {\n    return wasm.monochrome(photon_image.ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Convert an image to sepia.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to tint an image of type `PhotonImage`:\n* use photon::monochrome;\n* monochrome::sepia(&mut img);\n* ```\n*\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function sepia(photon_image) {\n    return wasm.sepia(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale using the conventional averaging algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to convert an image of type `PhotonImage` to greyscale:\n* use photon::monochrome;\n* monochrome::grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function grayscale(photon_image) {\n    return wasm.grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale with a human corrected factor, to account for human vision.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to convert an image of type `PhotonImage` to greyscale with a human corrected factor:\n* use photon::monochrome;\n* monochrome::grayscale_human_corrected(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function grayscale_human_corrected(photon_image) {\n    return wasm.grayscale_human_corrected(photon_image.ptr);\n}\n\n/**\n* Desaturate an image by getting the min/max of each pixel\\'s RGB values.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to desaturate an image:\n* use photon::monochrome;\n* monochrome::desaturate(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function desaturate(photon_image) {\n    return wasm.desaturate(photon_image.ptr);\n}\n\n/**\n* Uses a min. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to decompose an image with min decomposition:\n* monochrome::decompose_min(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function decompose_min(photon_image) {\n    return wasm.decompose_min(photon_image.ptr);\n}\n\n/**\n* Uses a max. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* // For example, to decompose an image with max decomposition:\n* monochrome::decompose_max(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function decompose_max(photon_image) {\n    return wasm.decompose_max(photon_image.ptr);\n}\n\n/**\n* Employ only a limited number of gray shades in an image.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `num_shades` - The number of grayscale shades to be displayed in the image.\n* # Example\n*\n* ```\n* // For example, to limit an image to four shades of gray only:\n* monochrome::grayscale_shades(&mut img, 4);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_shades\n* @returns {void}\n*/\nexport function grayscale_shades(photon_image, num_shades) {\n    return wasm.grayscale_shades(photon_image.ptr, num_shades);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel\\'s 3 RGB values to the Red channel\\'s value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* monochrome::r_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function r_grayscale(photon_image) {\n    return wasm.r_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel\\'s 3 RGB values to the Green channel\\'s value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* monochrome::g_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function g_grayscale(photon_image) {\n    return wasm.g_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel\\'s 3 RGB values to the Blue channel\\'s value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```\n* monochrome::b_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {void}\n*/\nexport function b_grayscale(photon_image) {\n    return wasm.b_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel\\'s 3 RGB values to a chosen channel\\'s value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.\n* # Example\n* To grayscale using only values from the Red channel:\n* ```\n* monochrome::single_channel_grayscale(&mut img, 0);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel\n* @returns {void}\n*/\nexport function single_channel_grayscale(photon_image, channel) {\n    return wasm.single_channel_grayscale(photon_image.ptr, channel);\n}\n\n/**\n* Threshold an image using a standard thresholding algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `threshold` - The amount the image should be thresholded by from 0 to 255.\n* # Example\n*\n* ```\n* // For example, to threshold an image of type `PhotonImage`:\n* use photon::monochrome;\n* monochrome::threshold(&mut img, 30);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} threshold\n* @returns {void}\n*/\nexport function threshold(photon_image, threshold) {\n    return wasm.threshold(photon_image.ptr, threshold);\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8');\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n\nexport function __wbg_error_4bb6c2a97407129a(arg0, arg1) {\n    let varg0 = getStringFromWasm(arg0, arg1);\n\n    varg0 = varg0.slice();\n    wasm.__wbindgen_free(arg0, arg1 * 1);\n\n    console.error(varg0);\n}\n\nexport function __wbg_new_59cb74e423758ede() {\n    return addHeapObject(new Error());\n}\n\nexport function __wbg_stack_558ba5917b466edd(ret, arg0) {\n\n    const retptr = passStringToWasm(getObject(arg0).stack);\n    const retlen = WASM_VECTOR_LEN;\n    const mem = getUint32Memory();\n    mem[ret / 4] = retptr;\n    mem[ret / 4 + 1] = retlen;\n\n}\n\nexport function __widl_instanceof_CanvasRenderingContext2D(idx) { return getObject(idx) instanceof CanvasRenderingContext2D ? 1 : 0; }\n\nfunction handleError(exnptr, e) {\n    const view = getUint32Memory();\n    view[exnptr / 4] = 1;\n    view[exnptr / 4 + 1] = addHeapObject(e);\n}\n\nexport function __widl_f_get_image_data_CanvasRenderingContext2D(arg0, arg1, arg2, arg3, arg4, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).getImageData(arg1, arg2, arg3, arg4));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_put_image_data_CanvasRenderingContext2D(arg0, arg1, arg2, arg3, exnptr) {\n    try {\n        getObject(arg0).putImageData(getObject(arg1), arg2, arg3);\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_create_element_Document(arg0, arg1, arg2, exnptr) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    try {\n        return addHeapObject(getObject(arg0).createElement(varg1));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nexport function __widl_f_body_Document(arg0) {\n\n    const val = getObject(arg0).body;\n    return isLikeNone(val) ? 0 : addHeapObject(val);\n\n}\n\nexport function __widl_instanceof_HTMLCanvasElement(idx) { return getObject(idx) instanceof HTMLCanvasElement ? 1 : 0; }\n\nexport function __widl_f_get_context_HTMLCanvasElement(arg0, arg1, arg2, exnptr) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    try {\n\n        const val = getObject(arg0).getContext(varg1);\n        return isLikeNone(val) ? 0 : addHeapObject(val);\n\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_width_HTMLCanvasElement(arg0) {\n    return getObject(arg0).width;\n}\n\nexport function __widl_f_set_width_HTMLCanvasElement(arg0, arg1) {\n    getObject(arg0).width = arg1 >>> 0;\n}\n\nexport function __widl_f_height_HTMLCanvasElement(arg0) {\n    return getObject(arg0).height;\n}\n\nexport function __widl_f_set_height_HTMLCanvasElement(arg0, arg1) {\n    getObject(arg0).height = arg1 >>> 0;\n}\n\nlet cachegetUint8ClampedMemory = null;\nfunction getUint8ClampedMemory() {\n    if (cachegetUint8ClampedMemory === null || cachegetUint8ClampedMemory.buffer !== wasm.memory.buffer) {\n        cachegetUint8ClampedMemory = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachegetUint8ClampedMemory;\n}\n\nfunction getClampedArrayU8FromWasm(ptr, len) {\n    return getUint8ClampedMemory().subarray(ptr / 1, ptr / 1 + len);\n}\n\nexport function __widl_f_new_with_u8_clamped_array_and_sh_ImageData(arg0, arg1, arg2, arg3, exnptr) {\n    let varg0 = getClampedArrayU8FromWasm(arg0, arg1);\n    try {\n        return addHeapObject(new ImageData(varg0, arg2 >>> 0, arg3 >>> 0));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_data_ImageData(ret, arg0) {\n\n    const retptr = passArray8ToWasm(getObject(arg0).data);\n    const retlen = WASM_VECTOR_LEN;\n    const mem = getUint32Memory();\n    mem[ret / 4] = retptr;\n    mem[ret / 4 + 1] = retlen;\n\n}\n\nexport function __widl_f_append_child_Node(arg0, arg1, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).appendChild(getObject(arg1)));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __widl_f_set_text_content_Node(arg0, arg1, arg2) {\n    let varg1 = arg1 == 0 ? undefined : getStringFromWasm(arg1, arg2);\n    getObject(arg0).textContent = varg1;\n}\n\nexport function __widl_instanceof_Window(idx) { return getObject(idx) instanceof Window ? 1 : 0; }\n\nexport function __widl_f_document_Window(arg0) {\n\n    const val = getObject(arg0).document;\n    return isLikeNone(val) ? 0 : addHeapObject(val);\n\n}\n\nexport function __wbg_newnoargs_a172f39151049128(arg0, arg1) {\n    let varg0 = getStringFromWasm(arg0, arg1);\n    return addHeapObject(new Function(varg0));\n}\n\nexport function __wbg_call_8a9c8b0a32a202ff(arg0, arg1, exnptr) {\n    try {\n        return addHeapObject(getObject(arg0).call(getObject(arg1)));\n    } catch (e) {\n        handleError(exnptr, e);\n    }\n}\n\nexport function __wbindgen_debug_string(i, len_ptr) {\n    const debug_str =\n    val => {\n        // primitive types\n        const type = typeof val;\n        if (type == 'number' || type == 'boolean' || val == null) {\n            return  `${val}`;\n        }\n        if (type == 'string') {\n            return `\"${val}\"`;\n        }\n        if (type == 'symbol') {\n            const description = val.description;\n            if (description == null) {\n                return 'Symbol';\n            } else {\n                return `Symbol(${description})`;\n            }\n        }\n        if (type == 'function') {\n            const name = val.name;\n            if (typeof name == 'string' && name.length > 0) {\n                return `Function(${name})`;\n            } else {\n                return 'Function';\n            }\n        }\n        // objects\n        if (Array.isArray(val)) {\n            const length = val.length;\n            let debug = '[';\n            if (length > 0) {\n                debug += debug_str(val[0]);\n            }\n            for(let i = 1; i < length; i++) {\n                debug += ', ' + debug_str(val[i]);\n            }\n            debug += ']';\n            return debug;\n        }\n        // Test for built-in\n        const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n        let className;\n        if (builtInMatches.length > 1) {\n            className = builtInMatches[1];\n        } else {\n            // Failed to match the standard '[object ClassName]'\n            return toString.call(val);\n        }\n        if (className == 'Object') {\n            // we're a user defined class or Object\n            // JSON.stringify avoids problems with cycles, and is generally much\n            // easier than looping through ownProperties of `val`.\n            try {\n                return 'Object(' + JSON.stringify(val) + ')';\n            } catch (_) {\n                return 'Object';\n            }\n        }\n        // errors\n        if (val instanceof Error) {\n        return `${val.name}: ${val.message}\n        ${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n;\nconst toString = Object.prototype.toString;\nconst val = getObject(i);\nconst debug = debug_str(val);\nconst ptr = passStringToWasm(debug);\ngetUint32Memory()[len_ptr / 4] = WASM_VECTOR_LEN;\nreturn ptr;\n}\n\nexport function __wbindgen_rethrow(idx) { throw takeObject(idx); }\n\nexport function __wbindgen_throw(ptr, len) {\n    throw new Error(getStringFromWasm(ptr, len));\n}\n\nfunction freePhotonImage(ptr) {\n\n    wasm.__wbg_photonimage_free(ptr);\n}\n/**\n* Provides the image\\'s height, width, and contains the image\\'s raw pixels.\n* For use when communicating between JS and WASM, and also natively.\n*/\nexport class PhotonImage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PhotonImage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        freePhotonImage(ptr);\n    }\n\n    /**\n    * @param {number} width\n    * @param {number} height\n    * @returns {}\n    */\n    constructor(width, height) {\n        this.ptr = wasm.photonimage_new(width, height);\n    }\n    /**\n    * Convert ImageData to raw pixels, and update the PhotonImage\\'s raw pixels to this.\n    * @param {any} img_data\n    * @returns {void}\n    */\n    set_imgdata(img_data) {\n        return wasm.photonimage_set_imgdata(this.ptr, addHeapObject(img_data));\n    }\n    /**\n    * Create a new PhotonImage from ImageData.\n    * @param {number} width\n    * @param {number} height\n    * @param {any} imgdata\n    * @returns {PhotonImage}\n    */\n    static new_from_imgdata(width, height, imgdata) {\n        return PhotonImage.__wrap(wasm.photonimage_new_from_imgdata(width, height, addHeapObject(imgdata)));\n    }\n    /**\n    * Create a new PhotonImage from a base64 string.\n    * @param {string} base64\n    * @returns {PhotonImage}\n    */\n    static new_from_base64(base64) {\n        const ptr0 = passStringToWasm(base64);\n        const len0 = WASM_VECTOR_LEN;\n        try {\n            return PhotonImage.__wrap(wasm.photonimage_new_from_base64(ptr0, len0));\n\n        } finally {\n            wasm.__wbindgen_free(ptr0, len0 * 1);\n\n        }\n\n    }\n    /**\n    * Create a new PhotonImage from a raw Vec of u8s representing raw image pixels.\n    * @param {Uint8Array} vec\n    * @returns {PhotonImage}\n    */\n    static new_from_vec(vec) {\n        const ptr0 = passArray8ToWasm(vec);\n        const len0 = WASM_VECTOR_LEN;\n        return PhotonImage.__wrap(wasm.photonimage_new_from_vec(ptr0, len0));\n    }\n    /**\n    * Get the width of the PhotonImage.\n    * @returns {number}\n    */\n    get_width() {\n        return wasm.photonimage_get_width(this.ptr) >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    get_raw_pixels() {\n        const retptr = globalArgumentPtr();\n        wasm.photonimage_get_raw_pixels(retptr, this.ptr);\n        const mem = getUint32Memory();\n        const rustptr = mem[retptr / 4];\n        const rustlen = mem[retptr / 4 + 1];\n\n        const realRet = getArrayU8FromWasm(rustptr, rustlen).slice();\n        wasm.__wbindgen_free(rustptr, rustlen * 1);\n        return realRet;\n\n    }\n    /**\n    * Get the height of the PhotonImage.\n    * @returns {number}\n    */\n    get_height() {\n        return wasm.photonimage_get_height(this.ptr) >>> 0;\n    }\n    /**\n    * Convert the PhotonImage\\'s raw pixels to JS-compatible ImageData.\n    * @returns {any}\n    */\n    get_image_data() {\n        return takeObject(wasm.photonimage_get_image_data(this.ptr));\n    }\n}\n\nfunction freeRgb(ptr) {\n\n    wasm.__wbg_rgb_free(ptr);\n}\n/**\n* RGB color type.\n*/\nexport class Rgb {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Rgb.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        freeRgb(ptr);\n    }\n\n    /**\n    * @param {number} r\n    * @param {number} g\n    * @param {number} b\n    * @returns {Rgb}\n    */\n    static new(r, g, b) {\n        return Rgb.__wrap(wasm.rgb_new(r, g, b));\n    }\n    /**\n    * @param {number} r\n    * @returns {void}\n    */\n    set_red(r) {\n        return wasm.rgb_set_red(this.ptr, r);\n    }\n    /**\n    * @param {number} g\n    * @returns {void}\n    */\n    set_green(g) {\n        return wasm.rgb_set_green(this.ptr, g);\n    }\n    /**\n    * @param {number} b\n    * @returns {void}\n    */\n    set_blue(b) {\n        return wasm.rgb_set_blue(this.ptr, b);\n    }\n    /**\n    * @returns {number}\n    */\n    get_red() {\n        return wasm.rgb_get_red(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get_green() {\n        return wasm.rgb_get_green(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get_blue() {\n        return wasm.rgb_get_blue(this.ptr);\n    }\n}\n\nexport function __wbindgen_object_clone_ref(idx) {\n    return addHeapObject(getObject(idx));\n}\n\nexport function __wbindgen_object_drop_ref(i) { dropObject(i); }\n\n"],"sourceRoot":""}