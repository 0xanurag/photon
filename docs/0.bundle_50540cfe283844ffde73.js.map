{"version":3,"sources":["webpack:///../crate/pkg/photon_rs.js","webpack:///../crate/pkg/photon_rs_bg.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/buildin/global.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","addHeapObject","obj","WASM_VECTOR_LEN","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","cachedTextEncoder","TextEncoder","module","require","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","ptr","subarray","len","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","getStringFromWasm0","decode","_assertClass","instance","klass","Error","name","crop","photon_image","x1","y1","x2","y2","PhotonImage","__wrap","crop_img_browser","source_canvas","width","height","left","top","fliph","flipv","resize_img_browser","photon_img","sampling_filter","resize","seam_carve","img","noise_reduction","sharpen","edge_detection","identity","box_blur","gaussian_blur","radius","detect_horizontal_lines","detect_vertical_lines","detect_45_deg_lines","detect_135_deg_lines","laplace","edge_one","emboss","sobel_horizontal","prewitt_horizontal","sobel_vertical","alter_channel","channel","amt","alter_red_channel","alter_green_channel","alter_blue_channel","alter_two_channels","channel1","amt1","channel2","amt2","alter_channels","r_amt","g_amt","b_amt","remove_channel","min_filter","remove_red_channel","remove_green_channel","remove_blue_channel","swap_channels","invert","monochrome","r_offset","g_offset","b_offset","sepia","grayscale","grayscale_human_corrected","desaturate","decompose_min","decompose_max","grayscale_shades","num_shades","r_grayscale","g_grayscale","b_grayscale","single_channel_grayscale","threshold","watermark","x","y","blend","photon_image2","blend_mode","ptr0","len0","create_gradient","apply_gradient","image","passArray8ToWasm0","getArrayU8FromWasm0","run","stack_pointer","addBorrowedObject","get_image_data","canvas","ctx","putImageData","new_image","open_image","to_raw_pixels","imgdata","retptr","value","r0","r1","v0","base64_to_image","base64","base64_to_vec","v1","to_image_data","channel_index","offset_red","offset_amt","offset_green","offset_blue","multiple_offsets","channel_index2","primary","colorize","solarize","solarize_retimg","inc_brightness","brightness","adjust_contrast","contrast","tint","horizontal_strips","num_strips","vertical_strips","neue","lix","ryo","filter","filter_name","lofi","pastel_pink","golden","cali","dramatic","firenze","obsidian","lch","mode","hsl","hsv","hue_rotate_hsl","degrees","hue_rotate_hsv","hue_rotate_lch","saturate_hsl","level","saturate_lch","saturate_hsv","lighten_lch","lighten_hsl","lighten_hsv","darken_lch","darken_hsl","darken_hsv","desaturate_hsv","desaturate_hsl","desaturate_lch","mix_with_colour","mix_colour","opacity","Rgb","selective_lighten","ref_color","selective_desaturate","selective_saturate","selective_greyscale","ptr1","selective_hue_rotate","isLikeNone","handleError","f","apply","this","arguments","e","cachegetUint8ClampedMemory0","getClampedArrayU8FromWasm0","Uint8ClampedArray","SamplingFilter","Object","freeze","Nearest","Triangle","CatmullRom","Gaussian","Lanczos3","raw_pixels","create","prototype","img_data","vec","r","g","b","__wbindgen_object_drop_ref","arg0","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","arg1","stack","__wbg_error_4bb6c2a97407129a","console","error","__wbg_instanceof_Window_adf3196bdc02b386","Window","__wbg_document_6cc8d0b87c0a99b9","document","__wbg_body_8c888fe47d81765f","body","__wbg_createElement_5bdf88a5af9f17c5","arg2","createElement","__wbg_width_a85cf756c1966efd","__wbg_height_52fa5698ae65262a","__wbg_data_c2cd7a48734589b2","data","__wbg_newwithu8clampedarrayandsh_104cc36644cfc313","arg3","ImageData","__wbg_instanceof_CanvasRenderingContext2d_5b86ec94bce38d5b","CanvasRenderingContext2D","__wbg_drawImage_1ed23ae3d5cef9bb","arg4","arg5","arg6","arg7","arg8","arg9","drawImage","__wbg_getImageData_888c08c04395524a","getImageData","__wbg_putImageData_dcb576c1e3408468","__wbg_settextContent_9ac5ef9163ad40d0","textContent","__wbg_appendChild_77215fd672b162c5","appendChild","__wbg_instanceof_HtmlCanvasElement_4f5b5ec6cd53ccf3","HTMLCanvasElement","__wbg_width_a22f9855caa54b53","__wbg_setwidth_5f26a8ba9dbfa0d0","__wbg_height_9a404a6b3c61c7ef","__wbg_setheight_70f62727aa9383c2","__wbg_getContext_37ca0870acb096d9","getContext","__wbg_call_8e95613cc6524977","call","__wbindgen_object_clone_ref","__wbg_newnoargs_f3b8a801d5d4b079","Function","__wbg_self_07b2f89e82ceb76d","self","__wbg_window_ba85d88572adc0dc","window","__wbg_globalThis_b9277fc37e201fe5","globalThis","__wbg_global_e16303fe83e1d57f","global","__wbindgen_is_undefined","__wbindgen_debug_string","debugString","val","type","description","isArray","debug","i","className","builtInMatches","exec","toString","JSON","stringify","_","message","__wbindgen_throw","__wbindgen_rethrow","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","get","l"],"mappings":"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","file":"0.bundle_50540cfe283844ffde73.js","sourcesContent":["import * as wasm from \"./photon_rs_bg.wasm\";\nexport * from \"./photon_rs_bg.js\";","import * as wasm from './photon_rs_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* Crop an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to crop an image at (0, 0) to (500, 800)\n* use photon_rs::native::{open_image, save_image};\n* use photon_rs::transform::crop;\n* use photon_rs::PhotonImage;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let cropped_img: PhotonImage = crop(&mut img, 0_u32, 0_u32, 500_u32, 800_u32);\n* // Write the contents of this image in JPG format.\n* save_image(cropped_img, \"cropped_image.jpg\").expect(\"Should save file\");\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} x1\n* @param {number} y1\n* @param {number} x2\n* @param {number} y2\n* @returns {PhotonImage}\n*/\nexport function crop(photon_image, x1, y1, x2, y2) {\n    _assertClass(photon_image, PhotonImage);\n    var ret = wasm.crop(photon_image.ptr, x1, y1, x2, y2);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* @param {HTMLCanvasElement} source_canvas\n* @param {number} width\n* @param {number} height\n* @param {number} left\n* @param {number} top\n* @returns {HTMLCanvasElement}\n*/\nexport function crop_img_browser(source_canvas, width, height, left, top) {\n    var ret = wasm.crop_img_browser(addHeapObject(source_canvas), width, height, left, top);\n    return takeObject(ret);\n}\n\n/**\n* Flip an image horizontally.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to flip an image horizontally:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::fliph;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* fliph(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function fliph(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.fliph(photon_image.ptr);\n}\n\n/**\n* Flip an image vertically.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to flip an image vertically:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::flipv;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* flipv(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function flipv(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.flipv(photon_image.ptr);\n}\n\n/**\n* Resize an image on the web.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n* @param {PhotonImage} photon_img\n* @param {number} width\n* @param {number} height\n* @param {number} sampling_filter\n* @returns {HTMLCanvasElement}\n*/\nexport function resize_img_browser(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    var ret = wasm.resize_img_browser(photon_img.ptr, width, height, sampling_filter);\n    return takeObject(ret);\n}\n\n/**\n* Resize an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n* * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n* @param {PhotonImage} photon_img\n* @param {number} width\n* @param {number} height\n* @param {number} sampling_filter\n* @returns {PhotonImage}\n*/\nexport function resize(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    var ret = wasm.resize(photon_img.ptr, width, height, sampling_filter);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Resize image using seam carver.\n* Resize only if new dimensions are smaller, than original image.\n* # NOTE: This is still experimental feature, and pretty slow.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `width` - New width.\n* * `height` - New height.\n*\n* # Example\n*\n* ```no_run\n* // For example, resize image using seam carver:\n* use photon_rs::native::open_image;\n* use photon_rs::transform::seam_carve;\n* use photon_rs::PhotonImage;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let result: PhotonImage = seam_carve(&img, 100_u32, 100_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nexport function seam_carve(img, width, height) {\n    _assertClass(img, PhotonImage);\n    var ret = wasm.seam_carve(img.ptr, width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Noise reduction.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to noise reduct an image:\n* use photon_rs::conv::noise_reduction;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* noise_reduction(&mut img);\n* ```\n* Adds a constant to a select R, G, or B channel's value.\n* @param {PhotonImage} photon_image\n*/\nexport function noise_reduction(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.noise_reduction(photon_image.ptr);\n}\n\n/**\n* Sharpen an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to sharpen an image:\n* use photon_rs::conv::sharpen;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sharpen(&mut img);\n* ```\n* Adds a constant to a select R, G, or B channel's value.\n* @param {PhotonImage} photon_image\n*/\nexport function sharpen(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sharpen(photon_image.ptr);\n}\n\n/**\n* Apply edge detection to an image, to create a dark version with its edges highlighted.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::conv::edge_detection;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* edge_detection(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function edge_detection(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_detection(photon_image.ptr);\n}\n\n/**\n* Apply an identity kernel convolution to an image.\n*\n* # Arguments\n* * `img` -A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply an identity kernel convolution:\n* use photon_rs::conv::identity;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* identity(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function identity(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.identity(photon_image.ptr);\n}\n\n/**\n* Apply a box blur effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a box blur effect:\n* use photon_rs::conv::box_blur;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* box_blur(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function box_blur(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.box_blur(photon_image.ptr);\n}\n\n/**\n* Gaussian blur in linear time.\n*\n* Reference: http://blog.ivank.net/fastest-gaussian-blur.html\n*\n* # Arguments\n* * `photon_image` - A PhotonImage\n* * `radius` - blur radius\n* # Example\n*\n* ```no_run\n* use photon_rs::conv::gaussian_blur;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* gaussian_blur(&mut img, 3_i32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} radius\n*/\nexport function gaussian_blur(photon_image, radius) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.gaussian_blur(photon_image.ptr, radius);\n}\n\n/**\n* Detect horizontal lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the horizontal lines in an image:\n* use photon_rs::conv::detect_horizontal_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_horizontal_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function detect_horizontal_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_horizontal_lines(photon_image.ptr);\n}\n\n/**\n* Detect vertical lines in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the vertical lines in an image:\n* use photon_rs::conv::detect_vertical_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_vertical_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function detect_vertical_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_vertical_lines(photon_image.ptr);\n}\n\n/**\n* Detect lines at a forty five degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the lines at a forty five degree angle in an image:\n* use photon_rs::conv::detect_45_deg_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_45_deg_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function detect_45_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_45_deg_lines(photon_image.ptr);\n}\n\n/**\n* Detect lines at a 135 degree angle in an image, and highlight these only.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to display the lines at a 135 degree angle in an image:\n* use photon_rs::conv::detect_135_deg_lines;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* detect_135_deg_lines(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function detect_135_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_135_deg_lines(photon_image.ptr);\n}\n\n/**\n* Apply a standard laplace convolution.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a laplace effect:\n* use photon_rs::conv::laplace;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* laplace(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function laplace(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.laplace(photon_image.ptr);\n}\n\n/**\n* Preset edge effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply this effect:\n* use photon_rs::conv::edge_one;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* edge_one(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function edge_one(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_one(photon_image.ptr);\n}\n\n/**\n* Apply an emboss effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply an emboss effect:\n* use photon_rs::conv::emboss;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* emboss(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function emboss(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.emboss(photon_image.ptr);\n}\n\n/**\n* Apply a horizontal Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a horizontal Sobel filter:\n* use photon_rs::conv::sobel_horizontal;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sobel_horizontal(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function sobel_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_horizontal(photon_image.ptr);\n}\n\n/**\n* Apply a horizontal Prewitt convolution to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a horizontal Prewitt convolution effect:\n* use photon_rs::conv::prewitt_horizontal;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* prewitt_horizontal(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function prewitt_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.prewitt_horizontal(photon_image.ptr);\n}\n\n/**\n* Apply a vertical Sobel filter to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a vertical Sobel filter:\n* use photon_rs::conv::sobel_vertical;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sobel_vertical(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function sobel_vertical(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_vertical(photon_image.ptr);\n}\n\n/**\n* Alter a select channel by incrementing or decrementing its value by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,\n* representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)\n* * `amount` - The amount to increment/decrement the channel's value by for that pixel.\n* A positive value will increment/decrement the channel's value, a negative value will decrement the channel's value.\n*\n* ## Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::channels::alter_channel;\n* use photon_rs::native::{open_image, save_image};\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channel(&mut img, 0_usize, 10_i16);\n* // Write the contents of this image in JPG format.\n* save_image(img, \"new_image.jpg\").expect(\"File should be saved\");\n* ```\n*\n* Adds a constant to a select R, G, or B channel's value.\n*\n* ### Decrease a channel's value\n* // For example, to decrease the Green channel for all pixels by 20:\n* ```no_run\n* use photon_rs::channels::alter_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channel(&mut img, 1_usize, -20_i16);\n* ```\n* **Note**: Note the use of a minus symbol when decreasing the channel.\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} amt\n*/\nexport function alter_channel(img, channel, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channel(img.ptr, channel, amt);\n}\n\n/**\n* Increment or decrement every pixel's Red channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage. See the PhotonImage struct for details.\n* * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Red channel for all pixels by 10:\n* use photon_rs::channels::alter_red_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_red_channel(&mut img, 10_i16);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} amt\n*/\nexport function alter_red_channel(photon_image, amt) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.alter_red_channel(photon_image.ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel's Green channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment/decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Green channel for all pixels by 20:\n* use photon_rs::channels::alter_green_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_green_channel(&mut img, 20_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n*/\nexport function alter_green_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_green_channel(img.ptr, amt);\n}\n\n/**\n* Increment or decrement every pixel's Blue channel by a constant.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the Blue channel for all pixels by 10:\n* use photon_rs::channels::alter_blue_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_blue_channel(&mut img, 10_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} amt\n*/\nexport function alter_blue_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_blue_channel(img.ptr, amt);\n}\n\n/**\n* Increment/decrement two channels' values simultaneously by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt1` - The amount to increment/decrement the channel's value by for that pixel.\n* * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.\n* * `amt2` - The amount to increment/decrement the channel's value by for that pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the values of the Red and Blue channels per pixel:\n* use photon_rs::channels::alter_two_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_two_channels(&mut img, 0_usize, 10_i16, 2_usize, 20_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} amt1\n* @param {number} channel2\n* @param {number} amt2\n*/\nexport function alter_two_channels(img, channel1, amt1, channel2, amt2) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_two_channels(img.ptr, channel1, amt1, channel2, amt2);\n}\n\n/**\n* Increment all 3 channels' values by adding an amt to each channel per pixel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `r_amt` - The amount to increment/decrement the Red channel by.\n* * `g_amt` - The amount to increment/decrement the Green channel by.\n* * `b_amt` - The amount to increment/decrement the Blue channel by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n* // and the Blue channel by 50:\n* use photon_rs::channels::alter_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* alter_channels(&mut img, 10_i16, 20_i16, 50_i16);\n* ```\n* @param {PhotonImage} img\n* @param {number} r_amt\n* @param {number} g_amt\n* @param {number} b_amt\n*/\nexport function alter_channels(img, r_amt, g_amt, b_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channels(img.ptr, r_amt, g_amt, b_amt);\n}\n\n/**\n* Set a certain channel to zero, thus removing the channel's influence in the pixels' final rendered colour.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n* * `min_filter` - Minimum filter. Value between 0 and 255. Only remove the channel if the current pixel's channel value is less than this minimum filter. To completely\n* remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n* then channel would be 0 and min_filter would be 50.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the Red channel with a min_filter of 100:\n* use photon_rs::channels::remove_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_channel(&mut img, 0_usize, 100_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel\n* @param {number} min_filter\n*/\nexport function remove_channel(img, channel, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_channel(img.ptr, channel, min_filter);\n}\n\n/**\n* Remove the Red channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the red channel for red channel pixel values less than 50:\n* use photon_rs::channels::remove_red_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_red_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nexport function remove_red_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_red_channel(img.ptr, min_filter);\n}\n\n/**\n* Remove the Green channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the green channel for green channel pixel values less than 50:\n* use photon_rs::channels::remove_green_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_green_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nexport function remove_green_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_green_channel(img.ptr, min_filter);\n}\n\n/**\n* Remove the Blue channel's influence in an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n*\n* # Example\n*\n* ```no_run\n* // For example, to remove the blue channel for blue channel pixel values less than 50:\n* use photon_rs::channels::remove_blue_channel;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* remove_blue_channel(&mut img, 50_u8);\n* ```\n* @param {PhotonImage} img\n* @param {number} min_filter\n*/\nexport function remove_blue_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_blue_channel(img.ptr, min_filter);\n}\n\n/**\n* Swap two channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n* * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n*\n* # Example\n*\n* ```no_run\n* // For example, to swap the values of the Red channel with the values of the Blue channel:\n* use photon_rs::channels::swap_channels;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* swap_channels(&mut img, 0_usize, 2_usize);\n* ```\n* @param {PhotonImage} img\n* @param {number} channel1\n* @param {number} channel2\n*/\nexport function swap_channels(img, channel1, channel2) {\n    _assertClass(img, PhotonImage);\n    wasm.swap_channels(img.ptr, channel1, channel2);\n}\n\n/**\n* Invert RGB value of an image.\n*\n* # Arguments\n* * `photon_image` - A DynamicImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* use photon_rs::channels::invert;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* invert(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function invert(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.invert(photon_image.ptr);\n}\n\n/**\n* Apply a monochrome effect of a certain colour.\n*\n* It does so by averaging the R, G, and B values of a pixel, and then adding a\n* separate value to that averaged value for each channel to produce a tint.\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `r_offset` - The value to add to the Red channel per pixel.\n* * `g_offset` - The value to add to the Green channel per pixel.\n* * `b_offset` - The value to add to the Blue channel per pixel.\n*\n* # Example\n*\n* ```no_run\n* // For example, to apply a monochrome effect to an image:\n* use photon_rs::monochrome::monochrome;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* monochrome(&mut img, 40_u32, 50_u32, 100_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n*/\nexport function monochrome(img, r_offset, g_offset, b_offset) {\n    _assertClass(img, PhotonImage);\n    wasm.monochrome(img.ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Convert an image to sepia.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to sepia an image of type `PhotonImage`:\n* use photon_rs::monochrome::sepia;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* sepia(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function sepia(img) {\n    _assertClass(img, PhotonImage);\n    wasm.sepia(img.ptr);\n}\n\n/**\n* Convert an image to grayscale using the conventional averaging algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to convert an image of type `PhotonImage` to grayscale:\n* use photon_rs::monochrome::grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function grayscale(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale(img.ptr);\n}\n\n/**\n* Convert an image to grayscale with a human corrected factor, to account for human vision.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to convert an image of type `PhotonImage` to grayscale with a human corrected factor:\n* use photon_rs::monochrome::grayscale_human_corrected;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale_human_corrected(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function grayscale_human_corrected(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale_human_corrected(img.ptr);\n}\n\n/**\n* Desaturate an image by getting the min/max of each pixel's RGB values.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to desaturate an image:\n* use photon_rs::monochrome::desaturate;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function desaturate(img) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate(img.ptr);\n}\n\n/**\n* Uses a min. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to decompose an image with min decomposition:\n* use photon_rs::monochrome::decompose_min;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* decompose_min(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function decompose_min(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_min(img.ptr);\n}\n\n/**\n* Uses a max. decomposition algorithm to convert an image to greyscale.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* // For example, to decompose an image with max decomposition:\n* use photon_rs::monochrome::decompose_max;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* decompose_max(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function decompose_max(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_max(img.ptr);\n}\n\n/**\n* Employ only a limited number of gray shades in an image.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `num_shades` - The number of grayscale shades to be displayed in the image.\n* # Example\n*\n* ```no_run\n* // For example, to limit an image to four shades of gray only:\n* use photon_rs::monochrome::grayscale_shades;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* grayscale_shades(&mut img, 4_u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} num_shades\n*/\nexport function grayscale_shades(photon_image, num_shades) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.grayscale_shades(photon_image.ptr, num_shades);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Red channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::r_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* r_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function r_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.r_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Green channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::g_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* g_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function g_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.g_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to the Blue channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::monochrome::b_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* b_grayscale(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function b_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.b_grayscale(photon_image.ptr);\n}\n\n/**\n* Convert an image to grayscale by setting a pixel's 3 RGB values to a chosen channel's value.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.\n* # Example\n* To grayscale using only values from the Red channel:\n* ```no_run\n* use photon_rs::monochrome::single_channel_grayscale;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* single_channel_grayscale(&mut img, 0_usize);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel\n*/\nexport function single_channel_grayscale(photon_image, channel) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.single_channel_grayscale(photon_image.ptr, channel);\n}\n\n/**\n* Threshold an image using a standard thresholding algorithm.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `threshold` - The amount the image should be thresholded by from 0 to 255.\n* # Example\n*\n* ```no_run\n* // For example, to threshold an image of type `PhotonImage`:\n* use photon_rs::monochrome::threshold;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* threshold(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} threshold\n*/\nexport function threshold(img, threshold) {\n    _assertClass(img, PhotonImage);\n    wasm.threshold(img.ptr, threshold);\n}\n\n/**\n* Add a watermark to an image.\n*\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `watermark` - The watermark to be placed onto the `img` image.\n* * `x` - The x coordinate where the watermark's top corner should be positioned.\n* * `y` - The y coordinate where the watermark's top corner should be positioned.\n* # Example\n*\n* ```no_run\n* // For example, to add a watermark to an image at x: 30, y: 40:\n* use photon_rs::multiple::watermark;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let water_mark = open_image(\"watermark.jpg\").expect(\"File should open\");\n* watermark(&mut img, &water_mark, 30_u32, 40_u32);\n* ```\n* @param {PhotonImage} img\n* @param {PhotonImage} watermark\n* @param {number} x\n* @param {number} y\n*/\nexport function watermark(img, watermark, x, y) {\n    _assertClass(img, PhotonImage);\n    _assertClass(watermark, PhotonImage);\n    wasm.watermark(img.ptr, watermark.ptr, x, y);\n}\n\n/**\n* Blend two images together.\n*\n* The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n* The blend modes available include: `overlay`, `over`, `atop`, `xor`, `multiply`, `burn`, `soft_light`, `hard_light`,\n* `difference`, `lighten`, `darken`, `dodge`, `plus`, `exclusion` (more to come)\n* NOTE: The first image must be smaller than the second image passed as params.\n* If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n* in the second image.\n* # Arguments\n* * `img` - A DynamicImage that contains a view into the image.\n* * `img2` - The 2nd DynamicImage to be blended with the first.\n* * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n* # Example\n*\n* ```no_run\n* // For example, to blend two images with the `multiply` blend mode:\n* use photon_rs::multiple::blend;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* let img2 = open_image(\"img2.jpg\").expect(\"File should open\");\n* blend(&mut img, &img2, \"multiply\");\n* ```\n* @param {PhotonImage} photon_image\n* @param {PhotonImage} photon_image2\n* @param {string} blend_mode\n*/\nexport function blend(photon_image, photon_image2, blend_mode) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(photon_image2, PhotonImage);\n    var ptr0 = passStringToWasm0(blend_mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.blend(photon_image.ptr, photon_image2.ptr, ptr0, len0);\n}\n\n/**\n* @param {number} width\n* @param {number} height\n* @returns {PhotonImage}\n*/\nexport function create_gradient(width, height) {\n    var ret = wasm.create_gradient(width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Apply a gradient to an image.\n* @param {PhotonImage} image\n*/\nexport function apply_gradient(image) {\n    _assertClass(image, PhotonImage);\n    wasm.apply_gradient(image.ptr);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* [temp] Check if WASM is supported.\n*/\nexport function run() {\n    wasm.run();\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Get the ImageData from a 2D canvas context\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @returns {ImageData}\n*/\nexport function get_image_data(canvas, ctx) {\n    try {\n        var ret = wasm.get_image_data(addBorrowedObject(canvas), addBorrowedObject(ctx));\n        return takeObject(ret);\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n    }\n}\n\n/**\n* Place a PhotonImage onto a 2D canvas.\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @param {PhotonImage} new_image\n*/\nexport function putImageData(canvas, ctx, new_image) {\n    _assertClass(new_image, PhotonImage);\n    var ptr0 = new_image.ptr;\n    new_image.ptr = 0;\n    wasm.putImageData(addHeapObject(canvas), addHeapObject(ctx), ptr0);\n}\n\n/**\n* Convert a HTML5 Canvas Element to a PhotonImage.\n*\n* This converts the ImageData found in the canvas context to a PhotonImage,\n* which can then have effects or filters applied to it.\n* @param {HTMLCanvasElement} canvas\n* @param {CanvasRenderingContext2D} ctx\n* @returns {PhotonImage}\n*/\nexport function open_image(canvas, ctx) {\n    var ret = wasm.open_image(addHeapObject(canvas), addHeapObject(ctx));\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Convert ImageData to a raw pixel vec of u8s.\n* @param {ImageData} imgdata\n* @returns {Uint8Array}\n*/\nexport function to_raw_pixels(imgdata) {\n    try {\n        const retptr = wasm.__wbindgen_export_2.value - 16;\n        wasm.__wbindgen_export_2.value = retptr;\n        wasm.to_raw_pixels(retptr, addHeapObject(imgdata));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        wasm.__wbindgen_export_2.value += 16;\n    }\n}\n\n/**\n* Convert a base64 string to a PhotonImage.\n* @param {string} base64\n* @returns {PhotonImage}\n*/\nexport function base64_to_image(base64) {\n    var ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.base64_to_image(ptr0, len0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Convert a base64 string to a Vec of u8s.\n* @param {string} base64\n* @returns {Uint8Array}\n*/\nexport function base64_to_vec(base64) {\n    try {\n        const retptr = wasm.__wbindgen_export_2.value - 16;\n        wasm.__wbindgen_export_2.value = retptr;\n        var ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.base64_to_vec(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_export_2.value += 16;\n    }\n}\n\n/**\n* Convert a PhotonImage to JS-compatible ImageData.\n* @param {PhotonImage} photon_image\n* @returns {ImageData}\n*/\nexport function to_image_data(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    var ret = wasm.to_image_data(ptr0);\n    return takeObject(ret);\n}\n\n/**\n* Adds an offset to the image by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```no_run\n* // For example, to offset pixels by 30 pixels on the red channel:\n* use photon_rs::effects::offset;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset(&mut img, 0_usize, 30_u32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} channel_index\n* @param {number} offset\n*/\nexport function offset(photon_image, channel_index, offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.offset(photon_image.ptr, channel_index, offset);\n}\n\n/**\n* Adds an offset to the red channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the red channel by.\n* # Example\n*\n* ```no_run\n* // For example, to add an offset to the red channel by 30 pixels.\n* use photon_rs::effects::offset_red;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_red(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nexport function offset_red(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_red(img.ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the green channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset you want to move the green channel by.\n* # Example\n*\n* ```no_run\n* // For example, to add an offset to the green channel by 30 pixels.\n* use photon_rs::effects::offset_green;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_green(&mut img, 30_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nexport function offset_green(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_green(img.ptr, offset_amt);\n}\n\n/**\n* Adds an offset to the blue channel by a certain number of pixels.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset_amt` - The offset you want to move the blue channel by.\n* # Example\n* // For example, to add an offset to the green channel by 40 pixels.\n*\n* ```no_run\n* use photon_rs::effects::offset_blue;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* offset_blue(&mut img, 40_u32);\n* ```\n* @param {PhotonImage} img\n* @param {number} offset_amt\n*/\nexport function offset_blue(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_blue(img.ptr, offset_amt);\n}\n\n/**\n* Adds multiple offsets to the image by a certain number of pixels (on two channels).\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `offset` - The offset is added to the pixels in the image.\n* # Example\n*\n* ```no_run\n* // For example, to add a 30-pixel offset to both the red and blue channels:\n* use photon_rs::effects::multiple_offsets;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* multiple_offsets(&mut img, 30_u32, 0_usize, 2_usize);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} offset\n* @param {number} channel_index\n* @param {number} channel_index2\n*/\nexport function multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.multiple_offsets(photon_image.ptr, offset, channel_index, channel_index2);\n}\n\n/**\n* Reduces an image to the primary colours.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to add a primary colour effect to an image of type `DynamicImage`:\n* use photon_rs::effects::primary;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* primary(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function primary(img) {\n    _assertClass(img, PhotonImage);\n    wasm.primary(img.ptr);\n}\n\n/**\n* Colorizes the green channels of the image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon_rs::effects::colorize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* colorize(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function colorize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.colorize(photon_image.ptr);\n}\n\n/**\n* Applies a solarizing effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to colorize an image of type `PhotonImage`:\n* use photon_rs::effects::solarize;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* solarize(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function solarize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.solarize(photon_image.ptr);\n}\n\n/**\n* Applies a solarizing effect to an image and returns the resulting PhotonImage.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* # Example\n*\n* ```no_run\n* // For example, to solarize \"retimg\" an image of type `PhotonImage`:\n* use photon_rs::effects::solarize_retimg;\n* use photon_rs::native::open_image;\n* use photon_rs::PhotonImage;\n*\n* let img = open_image(\"img.jpg\").expect(\"File should open\");\n* let result: PhotonImage = solarize_retimg(&img);\n* ```\n* @param {PhotonImage} photon_image\n* @returns {PhotonImage}\n*/\nexport function solarize_retimg(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    var ret = wasm.solarize_retimg(photon_image.ptr);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n* Increase the brightness of an image by a factor.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `brightness` - A u8 to add to the brightness.\n* # Example\n*\n* ```no_run\n* use photon_rs::effects::inc_brightness;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* inc_brightness(&mut img, 10_u8);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} brightness\n*/\nexport function inc_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.inc_brightness(photon_image.ptr, brightness);\n}\n\n/**\n* Adjust the contrast of an image by a factor.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `contrast` - An f32 factor used to adjust contrast. Between [-255.0, 255.0]. The algorithm will\n* clamp results if passed factor is out of range.\n* # Example\n*\n* ```no_run\n* use photon_rs::effects::adjust_contrast;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* adjust_contrast(&mut img, 30_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} contrast\n*/\nexport function adjust_contrast(photon_image, contrast) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.adjust_contrast(photon_image.ptr, contrast);\n}\n\n/**\n* Tint an image by adding an offset to averaged RGB channel values.\n*\n* # Arguments\n* * `img` - A PhotonImage that contains a view into the image.\n* * `r_offset` - The amount the R channel should be incremented by.\n* * `g_offset` - The amount the G channel should be incremented by.\n* * `b_offset` - The amount the B channel should be incremented by.\n* # Example\n*\n* ```no_run\n* // For example, to tint an image of type `PhotonImage`:\n* use photon_rs::effects::tint;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* tint(&mut img, 10_u32, 20_u32, 15_u32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {number} r_offset\n* @param {number} g_offset\n* @param {number} b_offset\n*/\nexport function tint(photon_image, r_offset, g_offset, b_offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.tint(photon_image.ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n* Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n*/\nexport function horizontal_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.horizontal_strips(photon_image.ptr, num_strips);\n}\n\n/**\n* Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.\n* @param {PhotonImage} photon_image\n* @param {number} num_strips\n*/\nexport function vertical_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.vertical_strips(photon_image.ptr, num_strips);\n}\n\n/**\n* Solarization on the Blue channel.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::neue;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* neue(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function neue(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.neue(photon_image.ptr);\n}\n\n/**\n* Solarization on the Red and Green channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::lix;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lix(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function lix(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.lix(photon_image.ptr);\n}\n\n/**\n* Solarization on the Red and Blue channels.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::ryo;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* ryo(&mut img);\n* ```\n* @param {PhotonImage} photon_image\n*/\nexport function ryo(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.ryo(photon_image.ptr);\n}\n\n/**\n* Apply a filter to an image. Over 20 filters are available.\n* The filters are as follows:\n* * **oceanic**: Add an aquamarine-tinted hue to an image.\n* * **islands**: Aquamarine tint.\n* * **marine**: Add a green/blue mixed hue to an image.\n* * **seagreen**: Dark green hue, with tones of blue.\n* * **flagblue**: Royal blue tint\n* * **liquid**: Blue-inspired tint.\n* * **diamante**: Custom filter with a blue/turquoise tint.\n* * **radio**: Fallout-style radio effect.\n* * **twenties**: Slight-blue tinted historical effect.\n* * **rosetint**: Rose-tinted filter.\n* * **mauve**: Purple-infused filter.\n* * **bluechrome**: Blue monochrome effect.\n* * **vintage**: Vintage filter with a red tint.\n* * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n* * **serenity**: Custom filter with an increase in the Blue channel's values.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `filter_name` - The filter's name. Choose from the selection above, eg: \"oceanic\"\n* # Example\n*\n* ```no_run\n* // For example, to add a filter called \"vintage\" to an image:\n* use photon_rs::filters::filter;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* filter(&mut img, \"vintage\");\n* ```\n* @param {PhotonImage} img\n* @param {string} filter_name\n*/\nexport function filter(img, filter_name) {\n    _assertClass(img, PhotonImage);\n    var ptr0 = passStringToWasm0(filter_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.filter(img.ptr, ptr0, len0);\n}\n\n/**\n* Apply a lofi effect to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::lofi;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lofi(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function lofi(img) {\n    _assertClass(img, PhotonImage);\n    wasm.lofi(img.ptr);\n}\n\n/**\n* Add a rose tint to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::pastel_pink;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* pastel_pink(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function pastel_pink(img) {\n    _assertClass(img, PhotonImage);\n    wasm.pastel_pink(img.ptr);\n}\n\n/**\n* Apply a vintage, golden hue to an image.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::golden;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* golden(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function golden(img) {\n    _assertClass(img, PhotonImage);\n    wasm.golden(img.ptr);\n}\n\n/**\n* Increased contrast filter effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::cali;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* cali(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function cali(img) {\n    _assertClass(img, PhotonImage);\n    wasm.cali(img.ptr);\n}\n\n/**\n* Increased contrast, greyscale effect.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::dramatic;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* dramatic(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function dramatic(img) {\n    _assertClass(img, PhotonImage);\n    wasm.dramatic(img.ptr);\n}\n\n/**\n* Apply a red hue, with increased contrast and brightness.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::firenze;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* firenze(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function firenze(img) {\n    _assertClass(img, PhotonImage);\n    wasm.firenze(img.ptr);\n}\n\n/**\n* Apply a greyscale effect with increased contrast.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* # Example\n*\n* ```no_run\n* use photon_rs::filters::obsidian;\n* use photon_rs::native::open_image;\n*\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* obsidian(&mut img);\n* ```\n* @param {PhotonImage} img\n*/\nexport function obsidian(img) {\n    _assertClass(img, PhotonImage);\n    wasm.obsidian(img.ptr);\n}\n\n/**\n* Apply gamma correction.\n* Image manipulation effects in the LCh colour space\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lch(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nexport function lch(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.lch(photon_image.ptr, ptr0, len0, amt);\n}\n\n/**\n* Image manipulation effects in the HSL colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hsl(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nexport function hsl(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.hsl(photon_image.ptr, ptr0, len0, amt);\n}\n\n/**\n* Image manipulation in the HSV colour space.\n*\n* Effects include:\n* * **saturate** - Saturation increase.\n* * **desaturate** - Desaturate the image.\n* * **shift_hue** - Hue rotation by a specified number of degrees.\n* * **darken** - Decrease the brightness.\n* * **lighten** - Increase the brightness.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage.\n* * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n* * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n*\n* # Example\n* ```no_run\n* // For example to increase the saturation by 10%:\n* use photon_rs::colour_spaces::hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hsv(&mut img, \"saturate\", 0.1_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {string} mode\n* @param {number} amt\n*/\nexport function hsv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.hsv(photon_image.ptr, ptr0, len0, amt);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon_rs::colour_spaces::hue_rotate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_hsl(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nexport function hue_rotate_hsl(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsl(img.ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:\n* use photon_rs::colour_spaces::hue_rotate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_hsv(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nexport function hue_rotate_hsv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsv(img.ptr, degrees);\n}\n\n/**\n* Shift hue by a specified number of degrees in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n*\n* # Example\n* ```no_run\n* // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n* use photon_rs::colour_spaces::hue_rotate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* hue_rotate_lch(&mut img, 120_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} degrees\n*/\nexport function hue_rotate_lch(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_lch(img.ptr, degrees);\n}\n\n/**\n* Increase the image's saturation by converting each pixel's colour to the HSL colour space\n* and increasing the colour's saturation.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::saturate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function saturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsl(img.ptr, level);\n}\n\n/**\n* Increase the image's saturation in the LCh colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 40% in the Lch colour space:\n* use photon_rs::colour_spaces::saturate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_lch(&mut img, 0.4_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function saturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_lch(img.ptr, level);\n}\n\n/**\n* Increase the image's saturation in the HSV colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Increasing saturation by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to increase saturation by 30% in the HSV colour space:\n* use photon_rs::colour_spaces::saturate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* saturate_hsv(&mut img, 0.3_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function saturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsv(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::lighten_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function lighten_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_lch(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSL colour space.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::lighten_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function lighten_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsl(img.ptr, level);\n}\n\n/**\n* Lighten an image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Lightening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to lighten an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::lighten_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* lighten_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function lighten_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsv(img.ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::darken_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function darken_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_lch(img.ptr, level);\n}\n\n/**\n* Darken the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the HSL colour space:\n* use photon_rs::colour_spaces::darken_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function darken_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsl(img.ptr, level);\n}\n\n/**\n* Darken the image's colours by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Darkening by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to darken an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::darken_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* darken_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function darken_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsv(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSV colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the HSV colour space:\n* use photon_rs::colour_spaces::desaturate_hsv;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_hsv(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function desaturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsv(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the HSL colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::desaturate_hsl;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_hsl(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function desaturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsl(img.ptr, level);\n}\n\n/**\n* Desaturate the image by a specified amount in the LCh colour space.\n*\n* # Arguments\n* * `img` - A PhotonImage.\n* * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n* The `level` must be from 0 to 1 in floating-point, `f32` format.\n* Desaturating by 80% would be represented by a `level` of 0.8\n*\n* # Example\n* ```no_run\n* // For example to desaturate an image by 10% in the LCh colour space:\n* use photon_rs::colour_spaces::desaturate_lch;\n* use photon_rs::native::open_image;\n*\n* // Open the image. A PhotonImage is returned.\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* desaturate_lch(&mut img, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {number} level\n*/\nexport function desaturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_lch(img.ptr, level);\n}\n\n/**\n* Mix image with a single color, supporting passing `opacity`.\n* The algorithm comes from Jimp. See `function mix` and `function colorFn` at following link:\n* https://github.com/oliver-moran/jimp/blob/29679faa597228ff2f20d34c5758e4d2257065a3/packages/plugin-color/src/index.js\n* Specifically, result_value = (mix_color_value - origin_value) * opacity + origin_value =\n* mix_color_value * opacity + (1 - opacity) * origin_value for each\n* of RGB channel.\n*\n* # Arguments\n* * `photon_image` - A PhotonImage that contains a view into the image.\n* * `mix_color` - the color to be mixed in, as an RGB value.\n* * `opacity` - the opacity of color when mixed to image. Float value from 0 to 1.\n* # Example\n*\n* ```no_run\n* // For example, to mix an image with rgb (50, 255, 254) and opacity 0.4:\n* use photon_rs::Rgb;\n* use photon_rs::colour_spaces::mix_with_colour;\n* use photon_rs::native::open_image;\n*\n* let mix_colour = Rgb::new(50_u8, 255_u8, 254_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* mix_with_colour(&mut img, mix_colour, 0.4_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} mix_colour\n* @param {number} opacity\n*/\nexport function mix_with_colour(photon_image, mix_colour, opacity) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(mix_colour, Rgb);\n    var ptr0 = mix_colour.ptr;\n    mix_colour.ptr = 0;\n    wasm.mix_with_colour(photon_image.ptr, ptr0, opacity);\n}\n\n/**\n* Selectively lighten an image.\n*\n* Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n* For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n*\n* # Example\n*\n* ```no_run\n* // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_lighten;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_lighten(&mut img, ref_color, 0.2_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nexport function selective_lighten(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.ptr;\n    ref_color.ptr = 0;\n    wasm.selective_lighten(img.ptr, ptr0, amt);\n}\n\n/**\n* Selectively desaturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of desaturate the colour by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_desaturate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_desaturate(&mut img, ref_color, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nexport function selective_desaturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.ptr;\n    ref_color.ptr = 0;\n    wasm.selective_desaturate(img.ptr, ptr0, amt);\n}\n\n/**\n* Selectively saturate pixel colours which are similar to the reference colour provided.\n*\n* Similarity between two colours is calculated via the CIE76 formula.\n* Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n* For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `amt` - The amount of saturate the colour by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_saturate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_saturate(&mut img, ref_color, 0.1_f32);\n* ```\n* @param {PhotonImage} img\n* @param {Rgb} ref_color\n* @param {number} amt\n*/\nexport function selective_saturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.ptr;\n    ref_color.ptr = 0;\n    wasm.selective_saturate(img.ptr, ptr0, amt);\n}\n\n/**\n* Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n* Only changes the colour of a pixel if its RGB values are within a specified range.\n*\n* (Similarity between two colours is calculated via the CIE76 formula.)\n* For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be\n* kept in the photo.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n*\n* # Example\n*\n* ```no_run\n* // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_greyscale;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_greyscale(img, ref_color);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n*/\nexport function selective_greyscale(photon_image, ref_color) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.ptr;\n    photon_image.ptr = 0;\n    _assertClass(ref_color, Rgb);\n    var ptr1 = ref_color.ptr;\n    ref_color.ptr = 0;\n    wasm.selective_greyscale(ptr0, ptr1);\n}\n\n/**\n* Selective hue rotation.\n*\n* Only rotate the hue of a pixel if its RGB values are within a specified range.\n* This function only rotates a pixel's hue to another  if it is visually similar to the colour specified.\n* For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.\n* # Arguments\n* * `img` - A PhotonImage.\n* * `ref_color` - The `RGB` value of the reference color (to be compared to)\n* * `degrees` - The amount of degrees to hue rotate by.\n*\n* # Example\n*\n* ```no_run\n* // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n* use photon_rs::Rgb;\n* use photon_rs::channels::selective_hue_rotate;\n* use photon_rs::native::open_image;\n*\n* let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n* let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n* selective_hue_rotate(&mut img, ref_color, 180_f32);\n* ```\n* @param {PhotonImage} photon_image\n* @param {Rgb} ref_color\n* @param {number} degrees\n*/\nexport function selective_hue_rotate(photon_image, ref_color, degrees) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.ptr;\n    ref_color.ptr = 0;\n    wasm.selective_hue_rotate(photon_image.ptr, ptr0, degrees);\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction handleError(f) {\n    return function () {\n        try {\n            return f.apply(this, arguments);\n\n        } catch (e) {\n            wasm.__wbindgen_exn_store(addHeapObject(e));\n        }\n    };\n}\n\nlet cachegetUint8ClampedMemory0 = null;\nfunction getUint8ClampedMemory0() {\n    if (cachegetUint8ClampedMemory0 === null || cachegetUint8ClampedMemory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8ClampedMemory0 = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachegetUint8ClampedMemory0;\n}\n\nfunction getClampedArrayU8FromWasm0(ptr, len) {\n    return getUint8ClampedMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n*/\nexport const SamplingFilter = Object.freeze({ Nearest:1,\"1\":\"Nearest\",Triangle:2,\"2\":\"Triangle\",CatmullRom:3,\"3\":\"CatmullRom\",Gaussian:4,\"4\":\"Gaussian\",Lanczos3:5,\"5\":\"Lanczos3\", });\n/**\n* Provides the image's height, width, and contains the image's raw pixels.\n* For use when communicating between JS and WASM, and also natively.\n*/\nexport class PhotonImage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PhotonImage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_photonimage_free(ptr);\n    }\n    /**\n    * Create a new PhotonImage from a Vec of u8s, which represent raw pixels.\n    * @param {Uint8Array} raw_pixels\n    * @param {number} width\n    * @param {number} height\n    */\n    constructor(raw_pixels, width, height) {\n        var ptr0 = passArray8ToWasm0(raw_pixels, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.photonimage_new(ptr0, len0, width, height);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a base64 string.\n    * @param {string} base64\n    * @returns {PhotonImage}\n    */\n    static new_from_base64(base64) {\n        var ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.photonimage_new_from_base64(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Create a new PhotonImage from a byteslice.\n    * @param {Uint8Array} vec\n    * @returns {PhotonImage}\n    */\n    static new_from_byteslice(vec) {\n        var ptr0 = passArray8ToWasm0(vec, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.photonimage_new_from_byteslice(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n    * Get the width of the PhotonImage.\n    * @returns {number}\n    */\n    get_width() {\n        var ret = wasm.photonimage_get_width(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the PhotonImage's pixels as a Vec of u8s.\n    * @returns {Uint8Array}\n    */\n    get_raw_pixels() {\n        try {\n            const retptr = wasm.__wbindgen_export_2.value - 16;\n            wasm.__wbindgen_export_2.value = retptr;\n            wasm.photonimage_get_raw_pixels(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_export_2.value += 16;\n        }\n    }\n    /**\n    * Get the height of the PhotonImage.\n    * @returns {number}\n    */\n    get_height() {\n        var ret = wasm.photonimage_get_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Convert the PhotonImage to base64.\n    * @returns {string}\n    */\n    get_base64() {\n        try {\n            const retptr = wasm.__wbindgen_export_2.value - 16;\n            wasm.__wbindgen_export_2.value = retptr;\n            wasm.photonimage_get_base64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_export_2.value += 16;\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Convert the PhotonImage's raw pixels to JS-compatible ImageData.\n    * @returns {ImageData}\n    */\n    get_image_data() {\n        var ret = wasm.photonimage_get_image_data(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Convert ImageData to raw pixels, and update the PhotonImage's raw pixels to this.\n    * @param {ImageData} img_data\n    */\n    set_imgdata(img_data) {\n        wasm.photonimage_set_imgdata(this.ptr, addHeapObject(img_data));\n    }\n}\n/**\n* RGB color type.\n*/\nexport class Rgb {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Rgb.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_rgb_free(ptr);\n    }\n    /**\n    * Create a new RGB struct.\n    * @param {number} r\n    * @param {number} g\n    * @param {number} b\n    */\n    constructor(r, g, b) {\n        var ret = wasm.rgb_new(r, g, b);\n        return Rgb.__wrap(ret);\n    }\n    /**\n    * Set the Red value.\n    * @param {number} r\n    */\n    set_red(r) {\n        wasm.rgb_set_red(this.ptr, r);\n    }\n    /**\n    * Get the Green value.\n    * @param {number} g\n    */\n    set_green(g) {\n        wasm.rgb_set_green(this.ptr, g);\n    }\n    /**\n    * Set the Blue value.\n    * @param {number} b\n    */\n    set_blue(b) {\n        wasm.rgb_set_blue(this.ptr, b);\n    }\n    /**\n    * Get the Red value.\n    * @returns {number}\n    */\n    get_red() {\n        var ret = wasm.rgb_get_red(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the Green value.\n    * @returns {number}\n    */\n    get_green() {\n        var ret = wasm.rgb_get_green(this.ptr);\n        return ret;\n    }\n    /**\n    * Get the Blue value.\n    * @returns {number}\n    */\n    get_blue() {\n        var ret = wasm.rgb_get_blue(this.ptr);\n        return ret;\n    }\n}\n\nexport const __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nexport const __wbg_new_59cb74e423758ede = function() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport const __wbg_stack_558ba5917b466edd = function(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport const __wbg_error_4bb6c2a97407129a = function(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport const __wbg_instanceof_Window_adf3196bdc02b386 = function(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport const __wbg_document_6cc8d0b87c0a99b9 = function(arg0) {\n    var ret = getObject(arg0).document;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport const __wbg_body_8c888fe47d81765f = function(arg0) {\n    var ret = getObject(arg0).body;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport const __wbg_createElement_5bdf88a5af9f17c5 = handleError(function(arg0, arg1, arg2) {\n    var ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));\n    return addHeapObject(ret);\n});\n\nexport const __wbg_width_a85cf756c1966efd = function(arg0) {\n    var ret = getObject(arg0).width;\n    return ret;\n};\n\nexport const __wbg_height_52fa5698ae65262a = function(arg0) {\n    var ret = getObject(arg0).height;\n    return ret;\n};\n\nexport const __wbg_data_c2cd7a48734589b2 = function(arg0, arg1) {\n    var ret = getObject(arg1).data;\n    var ptr0 = passArray8ToWasm0(ret, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport const __wbg_newwithu8clampedarrayandsh_104cc36644cfc313 = handleError(function(arg0, arg1, arg2, arg3) {\n    var ret = new ImageData(getClampedArrayU8FromWasm0(arg0, arg1), arg2 >>> 0, arg3 >>> 0);\n    return addHeapObject(ret);\n});\n\nexport const __wbg_instanceof_CanvasRenderingContext2d_5b86ec94bce38d5b = function(arg0) {\n    var ret = getObject(arg0) instanceof CanvasRenderingContext2D;\n    return ret;\n};\n\nexport const __wbg_drawImage_1ed23ae3d5cef9bb = handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n    getObject(arg0).drawImage(getObject(arg1), arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n});\n\nexport const __wbg_getImageData_888c08c04395524a = handleError(function(arg0, arg1, arg2, arg3, arg4) {\n    var ret = getObject(arg0).getImageData(arg1, arg2, arg3, arg4);\n    return addHeapObject(ret);\n});\n\nexport const __wbg_putImageData_dcb576c1e3408468 = handleError(function(arg0, arg1, arg2, arg3) {\n    getObject(arg0).putImageData(getObject(arg1), arg2, arg3);\n});\n\nexport const __wbg_settextContent_9ac5ef9163ad40d0 = function(arg0, arg1, arg2) {\n    getObject(arg0).textContent = arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2);\n};\n\nexport const __wbg_appendChild_77215fd672b162c5 = handleError(function(arg0, arg1) {\n    var ret = getObject(arg0).appendChild(getObject(arg1));\n    return addHeapObject(ret);\n});\n\nexport const __wbg_instanceof_HtmlCanvasElement_4f5b5ec6cd53ccf3 = function(arg0) {\n    var ret = getObject(arg0) instanceof HTMLCanvasElement;\n    return ret;\n};\n\nexport const __wbg_width_a22f9855caa54b53 = function(arg0) {\n    var ret = getObject(arg0).width;\n    return ret;\n};\n\nexport const __wbg_setwidth_5f26a8ba9dbfa0d0 = function(arg0, arg1) {\n    getObject(arg0).width = arg1 >>> 0;\n};\n\nexport const __wbg_height_9a404a6b3c61c7ef = function(arg0) {\n    var ret = getObject(arg0).height;\n    return ret;\n};\n\nexport const __wbg_setheight_70f62727aa9383c2 = function(arg0, arg1) {\n    getObject(arg0).height = arg1 >>> 0;\n};\n\nexport const __wbg_getContext_37ca0870acb096d9 = handleError(function(arg0, arg1, arg2) {\n    var ret = getObject(arg0).getContext(getStringFromWasm0(arg1, arg2));\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n});\n\nexport const __wbg_call_8e95613cc6524977 = handleError(function(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n});\n\nexport const __wbindgen_object_clone_ref = function(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport const __wbg_newnoargs_f3b8a801d5d4b079 = function(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport const __wbg_self_07b2f89e82ceb76d = handleError(function() {\n    var ret = self.self;\n    return addHeapObject(ret);\n});\n\nexport const __wbg_window_ba85d88572adc0dc = handleError(function() {\n    var ret = window.window;\n    return addHeapObject(ret);\n});\n\nexport const __wbg_globalThis_b9277fc37e201fe5 = handleError(function() {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n});\n\nexport const __wbg_global_e16303fe83e1d57f = handleError(function() {\n    var ret = global.global;\n    return addHeapObject(ret);\n});\n\nexport const __wbindgen_is_undefined = function(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport const __wbindgen_debug_string = function(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport const __wbindgen_rethrow = function(arg0) {\n    throw takeObject(arg0);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}